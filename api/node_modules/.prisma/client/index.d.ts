
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model cliente
 */

export type cliente = {
  id: number
  nombre: string | null
  apellido: string | null
  telefono: number | null
  direccion: string | null
}

/**
 * Model eventos
 */

export type eventos = {
  id: number
  fecha: Date | null
  hora: Date | null
  total: number | null
  idpaquete: number | null
  idcliente: number | null
  celebracion: string | null
  pagado: boolean | null
}

/**
 * Model paquete
 */

export type paquete = {
  id: number
  nombre: string | null
  adultos: number | null
  ninios: number | null
  precio: number | null
  preciounitario: number | null
}

/**
 * Model paqueteevento
 */

export type paqueteevento = {
  id: number
  adultos: number | null
  ninios: number | null
  total: number | null
  idpaquete: number | null
}

/**
 * Model abono
 */

export type abono = {
  id: number
  fecha: Date | null
  cantidad: number | null
  idcliente: number | null
  idpagos: number | null
}

/**
 * Model empleados
 */

export type empleados = {
  id: number
  nombre: string | null
  apellido: string | null
  direccion: string | null
  telefono: number | null
  descripcion: string | null
  idrol: number | null
}

/**
 * Model gastofijo
 */

export type gastofijo = {
  id: number
  nombre: string | null
  descripcion: string | null
  total: number | null
  activo: boolean | null
  idmes: number | null
}

/**
 * Model gastoseventos
 */

export type gastoseventos = {
  id: number
  monto: number | null
  motivo: string | null
  descripcion: string | null
  idmes: number | null
  idevento: number | null
}

/**
 * Model mes
 */

export type mes = {
  id: number
  mes: Date | null
  gastos: number | null
  ganancias: number | null
}

/**
 * Model pagos
 */

export type pagos = {
  id: number
  restante: number | null
  pagado: number | null
  total: number | null
  fechalimite: Date | null
  idevento: number | null
}

/**
 * Model rol
 */

export type rol = {
  id: number
  rol: string | null
}

/**
 * Model servicios
 */

export type servicios = {
  id: number
  nombre: string | null
  precio: number | null
  descripcion: string | null
}

/**
 * Model servicioseventos
 */

export type servicioseventos = {
  id: number
  idevento: number | null
  idservicio: number | null
  idempleado: number | null
  precio: number | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clientes
 * const clientes = await prisma.cliente.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clientes
   * const clientes = await prisma.cliente.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.cliente`: Exposes CRUD operations for the **cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.clienteDelegate<GlobalReject>;

  /**
   * `prisma.eventos`: Exposes CRUD operations for the **eventos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventos
    * const eventos = await prisma.eventos.findMany()
    * ```
    */
  get eventos(): Prisma.eventosDelegate<GlobalReject>;

  /**
   * `prisma.paquete`: Exposes CRUD operations for the **paquete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paquetes
    * const paquetes = await prisma.paquete.findMany()
    * ```
    */
  get paquete(): Prisma.paqueteDelegate<GlobalReject>;

  /**
   * `prisma.paqueteevento`: Exposes CRUD operations for the **paqueteevento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paqueteeventos
    * const paqueteeventos = await prisma.paqueteevento.findMany()
    * ```
    */
  get paqueteevento(): Prisma.paqueteeventoDelegate<GlobalReject>;

  /**
   * `prisma.abono`: Exposes CRUD operations for the **abono** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abonos
    * const abonos = await prisma.abono.findMany()
    * ```
    */
  get abono(): Prisma.abonoDelegate<GlobalReject>;

  /**
   * `prisma.empleados`: Exposes CRUD operations for the **empleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleados.findMany()
    * ```
    */
  get empleados(): Prisma.empleadosDelegate<GlobalReject>;

  /**
   * `prisma.gastofijo`: Exposes CRUD operations for the **gastofijo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gastofijos
    * const gastofijos = await prisma.gastofijo.findMany()
    * ```
    */
  get gastofijo(): Prisma.gastofijoDelegate<GlobalReject>;

  /**
   * `prisma.gastoseventos`: Exposes CRUD operations for the **gastoseventos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gastoseventos
    * const gastoseventos = await prisma.gastoseventos.findMany()
    * ```
    */
  get gastoseventos(): Prisma.gastoseventosDelegate<GlobalReject>;

  /**
   * `prisma.mes`: Exposes CRUD operations for the **mes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mes
    * const mes = await prisma.mes.findMany()
    * ```
    */
  get mes(): Prisma.mesDelegate<GlobalReject>;

  /**
   * `prisma.pagos`: Exposes CRUD operations for the **pagos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pagos.findMany()
    * ```
    */
  get pagos(): Prisma.pagosDelegate<GlobalReject>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.rolDelegate<GlobalReject>;

  /**
   * `prisma.servicios`: Exposes CRUD operations for the **servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicios.findMany()
    * ```
    */
  get servicios(): Prisma.serviciosDelegate<GlobalReject>;

  /**
   * `prisma.servicioseventos`: Exposes CRUD operations for the **servicioseventos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicioseventos
    * const servicioseventos = await prisma.servicioseventos.findMany()
    * ```
    */
  get servicioseventos(): Prisma.servicioseventosDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.24.1
   * Query Engine version: 18095475d5ee64536e2f93995e48ad800737a9e4
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    cliente: 'cliente',
    eventos: 'eventos',
    paquete: 'paquete',
    paqueteevento: 'paqueteevento',
    abono: 'abono',
    empleados: 'empleados',
    gastofijo: 'gastofijo',
    gastoseventos: 'gastoseventos',
    mes: 'mes',
    pagos: 'pagos',
    rol: 'rol',
    servicios: 'servicios',
    servicioseventos: 'servicioseventos'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model cliente
   */


  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
    max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
    telefono: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
    telefono: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    telefono: number | null
    direccion: string | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    telefono: number | null
    direccion: string | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    telefono: number
    direccion: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
    telefono?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
    telefono?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    telefono?: true
    direccion?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    telefono?: true
    direccion?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    telefono?: true
    direccion?: true
    _all?: true
  }

  export type ClienteAggregateArgs = {
    /**
     * Filter which cliente to aggregate.
     * 
    **/
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<clienteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }


    
    
  export type ClienteGroupByArgs = {
    where?: clienteWhereInput
    orderBy?: Enumerable<clienteOrderByInput>
    by: Array<ClienteScalarFieldEnum>
    having?: clienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }


  export type ClienteGroupByOutputType = {
    id: number
    nombre: string | null
    apellido: string | null
    telefono: number | null
    direccion: string | null
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Promise<
    Array<
      PickArray<ClienteGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ClienteGroupByOutputType[P]> 
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      > 
    >


  export type clienteSelect = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    telefono?: boolean
    direccion?: boolean
    abono?: boolean | abonoFindManyArgs
    eventos?: boolean | eventosFindManyArgs
  }

  export type clienteInclude = {
    abono?: boolean | abonoFindManyArgs
    eventos?: boolean | eventosFindManyArgs
  }

  export type clienteGetPayload<
    S extends boolean | null | undefined | clienteArgs,
    U = keyof S
      > = S extends true
        ? cliente
    : S extends undefined
    ? never
    : S extends clienteArgs | clienteFindManyArgs
    ?'include' extends U
    ? cliente  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'abono'
        ? Array < abonoGetPayload<S['include'][P]>>  :
        P extends 'eventos'
        ? Array < eventosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof cliente ?cliente [P]
  : 
          P extends 'abono'
        ? Array < abonoGetPayload<S['select'][P]>>  :
        P extends 'eventos'
        ? Array < eventosGetPayload<S['select'][P]>>  : never
  } 
    : cliente
  : cliente


  type clienteCountArgs = Merge<
    Omit<clienteFindManyArgs, 'select' | 'include'> & {
      select?: ClienteCountAggregateInputType | true
    }
  >

  export interface clienteDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {clienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clienteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, clienteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cliente'> extends True ? CheckSelect<T, Prisma__clienteClient<cliente>, Prisma__clienteClient<clienteGetPayload<T>>> : CheckSelect<T, Prisma__clienteClient<cliente | null >, Prisma__clienteClient<clienteGetPayload<T> | null >>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clienteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, clienteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cliente'> extends True ? CheckSelect<T, Prisma__clienteClient<cliente>, Prisma__clienteClient<clienteGetPayload<T>>> : CheckSelect<T, Prisma__clienteClient<cliente | null >, Prisma__clienteClient<clienteGetPayload<T> | null >>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends clienteFindManyArgs>(
      args?: SelectSubset<T, clienteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<cliente>>, PrismaPromise<Array<clienteGetPayload<T>>>>

    /**
     * Create a Cliente.
     * @param {clienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
    **/
    create<T extends clienteCreateArgs>(
      args: SelectSubset<T, clienteCreateArgs>
    ): CheckSelect<T, Prisma__clienteClient<cliente>, Prisma__clienteClient<clienteGetPayload<T>>>

    /**
     * Create many Clientes.
     *     @param {clienteCreateManyArgs} args - Arguments to create many Clientes.
     *     @example
     *     // Create many Clientes
     *     const cliente = await prisma.cliente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clienteCreateManyArgs>(
      args?: SelectSubset<T, clienteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cliente.
     * @param {clienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
    **/
    delete<T extends clienteDeleteArgs>(
      args: SelectSubset<T, clienteDeleteArgs>
    ): CheckSelect<T, Prisma__clienteClient<cliente>, Prisma__clienteClient<clienteGetPayload<T>>>

    /**
     * Update one Cliente.
     * @param {clienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clienteUpdateArgs>(
      args: SelectSubset<T, clienteUpdateArgs>
    ): CheckSelect<T, Prisma__clienteClient<cliente>, Prisma__clienteClient<clienteGetPayload<T>>>

    /**
     * Delete zero or more Clientes.
     * @param {clienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clienteDeleteManyArgs>(
      args?: SelectSubset<T, clienteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clienteUpdateManyArgs>(
      args: SelectSubset<T, clienteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {clienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
    **/
    upsert<T extends clienteUpsertArgs>(
      args: SelectSubset<T, clienteUpsertArgs>
    ): CheckSelect<T, Prisma__clienteClient<cliente>, Prisma__clienteClient<clienteGetPayload<T>>>

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends clienteCountArgs>(
      args?: Subset<T, clienteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__clienteClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    abono<T extends abonoFindManyArgs = {}>(args?: Subset<T, abonoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<abono>>, PrismaPromise<Array<abonoGetPayload<T>>>>;

    eventos<T extends eventosFindManyArgs = {}>(args?: Subset<T, eventosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<eventos>>, PrismaPromise<Array<eventosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * cliente findUnique
   */
  export type clienteFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
    /**
     * Throw an Error if a cliente can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which cliente to fetch.
     * 
    **/
    where: clienteWhereUniqueInput
  }


  /**
   * cliente findFirst
   */
  export type clienteFindFirstArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
    /**
     * Throw an Error if a cliente can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which cliente to fetch.
     * 
    **/
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<clienteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     * 
    **/
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     * 
    **/
    distinct?: Enumerable<ClienteScalarFieldEnum>
  }


  /**
   * cliente findMany
   */
  export type clienteFindManyArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
    /**
     * Filter, which clientes to fetch.
     * 
    **/
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<clienteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientes.
     * 
    **/
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClienteScalarFieldEnum>
  }


  /**
   * cliente create
   */
  export type clienteCreateArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
    /**
     * The data needed to create a cliente.
     * 
    **/
    data: XOR<clienteCreateInput, clienteUncheckedCreateInput>
  }


  /**
   * cliente createMany
   */
  export type clienteCreateManyArgs = {
    data: Enumerable<clienteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cliente update
   */
  export type clienteUpdateArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
    /**
     * The data needed to update a cliente.
     * 
    **/
    data: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
    /**
     * Choose, which cliente to update.
     * 
    **/
    where: clienteWhereUniqueInput
  }


  /**
   * cliente updateMany
   */
  export type clienteUpdateManyArgs = {
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyInput>
    where?: clienteWhereInput
  }


  /**
   * cliente upsert
   */
  export type clienteUpsertArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
    /**
     * The filter to search for the cliente to update in case it exists.
     * 
    **/
    where: clienteWhereUniqueInput
    /**
     * In case the cliente found by the `where` argument doesn't exist, create a new cliente with this data.
     * 
    **/
    create: XOR<clienteCreateInput, clienteUncheckedCreateInput>
    /**
     * In case the cliente was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
  }


  /**
   * cliente delete
   */
  export type clienteDeleteArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
    /**
     * Filter which cliente to delete.
     * 
    **/
    where: clienteWhereUniqueInput
  }


  /**
   * cliente deleteMany
   */
  export type clienteDeleteManyArgs = {
    where?: clienteWhereInput
  }


  /**
   * cliente without action
   */
  export type clienteArgs = {
    /**
     * Select specific fields to fetch from the cliente
     * 
    **/
    select?: clienteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: clienteInclude | null
  }



  /**
   * Model eventos
   */


  export type AggregateEventos = {
    _count: EventosCountAggregateOutputType | null
    count: EventosCountAggregateOutputType | null
    _avg: EventosAvgAggregateOutputType | null
    avg: EventosAvgAggregateOutputType | null
    _sum: EventosSumAggregateOutputType | null
    sum: EventosSumAggregateOutputType | null
    _min: EventosMinAggregateOutputType | null
    min: EventosMinAggregateOutputType | null
    _max: EventosMaxAggregateOutputType | null
    max: EventosMaxAggregateOutputType | null
  }

  export type EventosAvgAggregateOutputType = {
    id: number | null
    total: number | null
    idpaquete: number | null
    idcliente: number | null
  }

  export type EventosSumAggregateOutputType = {
    id: number | null
    total: number | null
    idpaquete: number | null
    idcliente: number | null
  }

  export type EventosMinAggregateOutputType = {
    id: number | null
    fecha: Date | null
    hora: Date | null
    total: number | null
    idpaquete: number | null
    idcliente: number | null
    celebracion: string | null
    pagado: boolean | null
  }

  export type EventosMaxAggregateOutputType = {
    id: number | null
    fecha: Date | null
    hora: Date | null
    total: number | null
    idpaquete: number | null
    idcliente: number | null
    celebracion: string | null
    pagado: boolean | null
  }

  export type EventosCountAggregateOutputType = {
    id: number
    fecha: number
    hora: number
    total: number
    idpaquete: number
    idcliente: number
    celebracion: number
    pagado: number
    _all: number
  }


  export type EventosAvgAggregateInputType = {
    id?: true
    total?: true
    idpaquete?: true
    idcliente?: true
  }

  export type EventosSumAggregateInputType = {
    id?: true
    total?: true
    idpaquete?: true
    idcliente?: true
  }

  export type EventosMinAggregateInputType = {
    id?: true
    fecha?: true
    hora?: true
    total?: true
    idpaquete?: true
    idcliente?: true
    celebracion?: true
    pagado?: true
  }

  export type EventosMaxAggregateInputType = {
    id?: true
    fecha?: true
    hora?: true
    total?: true
    idpaquete?: true
    idcliente?: true
    celebracion?: true
    pagado?: true
  }

  export type EventosCountAggregateInputType = {
    id?: true
    fecha?: true
    hora?: true
    total?: true
    idpaquete?: true
    idcliente?: true
    celebracion?: true
    pagado?: true
    _all?: true
  }

  export type EventosAggregateArgs = {
    /**
     * Filter which eventos to aggregate.
     * 
    **/
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     * 
    **/
    orderBy?: Enumerable<eventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eventos
    **/
    _count?: true | EventosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | EventosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: EventosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: EventosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: EventosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: EventosMaxAggregateInputType
  }

  export type GetEventosAggregateType<T extends EventosAggregateArgs> = {
        [P in keyof T & keyof AggregateEventos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventos[P]>
      : GetScalarType<T[P], AggregateEventos[P]>
  }


    
    
  export type EventosGroupByArgs = {
    where?: eventosWhereInput
    orderBy?: Enumerable<eventosOrderByInput>
    by: Array<EventosScalarFieldEnum>
    having?: eventosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventosCountAggregateInputType | true
    _avg?: EventosAvgAggregateInputType
    _sum?: EventosSumAggregateInputType
    _min?: EventosMinAggregateInputType
    _max?: EventosMaxAggregateInputType
  }


  export type EventosGroupByOutputType = {
    id: number
    fecha: Date | null
    hora: Date | null
    total: number | null
    idpaquete: number | null
    idcliente: number | null
    celebracion: string | null
    pagado: boolean | null
    _count: EventosCountAggregateOutputType | null
    _avg: EventosAvgAggregateOutputType | null
    _sum: EventosSumAggregateOutputType | null
    _min: EventosMinAggregateOutputType | null
    _max: EventosMaxAggregateOutputType | null
  }

  type GetEventosGroupByPayload<T extends EventosGroupByArgs> = Promise<
    Array<
      PickArray<EventosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof EventosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], EventosGroupByOutputType[P]> 
            : GetScalarType<T[P], EventosGroupByOutputType[P]>
        }
      > 
    >


  export type eventosSelect = {
    id?: boolean
    fecha?: boolean
    hora?: boolean
    total?: boolean
    idpaquete?: boolean
    idcliente?: boolean
    celebracion?: boolean
    pagado?: boolean
    cliente?: boolean | clienteArgs
    paqueteevento?: boolean | paqueteeventoArgs
    gastoseventos?: boolean | gastoseventosFindManyArgs
    pagos?: boolean | pagosFindManyArgs
    servicioseventos?: boolean | servicioseventosFindManyArgs
  }

  export type eventosInclude = {
    cliente?: boolean | clienteArgs
    paqueteevento?: boolean | paqueteeventoArgs
    gastoseventos?: boolean | gastoseventosFindManyArgs
    pagos?: boolean | pagosFindManyArgs
    servicioseventos?: boolean | servicioseventosFindManyArgs
  }

  export type eventosGetPayload<
    S extends boolean | null | undefined | eventosArgs,
    U = keyof S
      > = S extends true
        ? eventos
    : S extends undefined
    ? never
    : S extends eventosArgs | eventosFindManyArgs
    ?'include' extends U
    ? eventos  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cliente'
        ? clienteGetPayload<S['include'][P]> | null :
        P extends 'paqueteevento'
        ? paqueteeventoGetPayload<S['include'][P]> | null :
        P extends 'gastoseventos'
        ? Array < gastoseventosGetPayload<S['include'][P]>>  :
        P extends 'pagos'
        ? Array < pagosGetPayload<S['include'][P]>>  :
        P extends 'servicioseventos'
        ? Array < servicioseventosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof eventos ?eventos [P]
  : 
          P extends 'cliente'
        ? clienteGetPayload<S['select'][P]> | null :
        P extends 'paqueteevento'
        ? paqueteeventoGetPayload<S['select'][P]> | null :
        P extends 'gastoseventos'
        ? Array < gastoseventosGetPayload<S['select'][P]>>  :
        P extends 'pagos'
        ? Array < pagosGetPayload<S['select'][P]>>  :
        P extends 'servicioseventos'
        ? Array < servicioseventosGetPayload<S['select'][P]>>  : never
  } 
    : eventos
  : eventos


  type eventosCountArgs = Merge<
    Omit<eventosFindManyArgs, 'select' | 'include'> & {
      select?: EventosCountAggregateInputType | true
    }
  >

  export interface eventosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Eventos that matches the filter.
     * @param {eventosFindUniqueArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eventosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, eventosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'eventos'> extends True ? CheckSelect<T, Prisma__eventosClient<eventos>, Prisma__eventosClient<eventosGetPayload<T>>> : CheckSelect<T, Prisma__eventosClient<eventos | null >, Prisma__eventosClient<eventosGetPayload<T> | null >>

    /**
     * Find the first Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindFirstArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eventosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, eventosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'eventos'> extends True ? CheckSelect<T, Prisma__eventosClient<eventos>, Prisma__eventosClient<eventosGetPayload<T>>> : CheckSelect<T, Prisma__eventosClient<eventos | null >, Prisma__eventosClient<eventosGetPayload<T> | null >>

    /**
     * Find zero or more Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventos
     * const eventos = await prisma.eventos.findMany()
     * 
     * // Get first 10 Eventos
     * const eventos = await prisma.eventos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventosWithIdOnly = await prisma.eventos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends eventosFindManyArgs>(
      args?: SelectSubset<T, eventosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<eventos>>, PrismaPromise<Array<eventosGetPayload<T>>>>

    /**
     * Create a Eventos.
     * @param {eventosCreateArgs} args - Arguments to create a Eventos.
     * @example
     * // Create one Eventos
     * const Eventos = await prisma.eventos.create({
     *   data: {
     *     // ... data to create a Eventos
     *   }
     * })
     * 
    **/
    create<T extends eventosCreateArgs>(
      args: SelectSubset<T, eventosCreateArgs>
    ): CheckSelect<T, Prisma__eventosClient<eventos>, Prisma__eventosClient<eventosGetPayload<T>>>

    /**
     * Create many Eventos.
     *     @param {eventosCreateManyArgs} args - Arguments to create many Eventos.
     *     @example
     *     // Create many Eventos
     *     const eventos = await prisma.eventos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eventosCreateManyArgs>(
      args?: SelectSubset<T, eventosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Eventos.
     * @param {eventosDeleteArgs} args - Arguments to delete one Eventos.
     * @example
     * // Delete one Eventos
     * const Eventos = await prisma.eventos.delete({
     *   where: {
     *     // ... filter to delete one Eventos
     *   }
     * })
     * 
    **/
    delete<T extends eventosDeleteArgs>(
      args: SelectSubset<T, eventosDeleteArgs>
    ): CheckSelect<T, Prisma__eventosClient<eventos>, Prisma__eventosClient<eventosGetPayload<T>>>

    /**
     * Update one Eventos.
     * @param {eventosUpdateArgs} args - Arguments to update one Eventos.
     * @example
     * // Update one Eventos
     * const eventos = await prisma.eventos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eventosUpdateArgs>(
      args: SelectSubset<T, eventosUpdateArgs>
    ): CheckSelect<T, Prisma__eventosClient<eventos>, Prisma__eventosClient<eventosGetPayload<T>>>

    /**
     * Delete zero or more Eventos.
     * @param {eventosDeleteManyArgs} args - Arguments to filter Eventos to delete.
     * @example
     * // Delete a few Eventos
     * const { count } = await prisma.eventos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eventosDeleteManyArgs>(
      args?: SelectSubset<T, eventosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventos
     * const eventos = await prisma.eventos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eventosUpdateManyArgs>(
      args: SelectSubset<T, eventosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Eventos.
     * @param {eventosUpsertArgs} args - Arguments to update or create a Eventos.
     * @example
     * // Update or create a Eventos
     * const eventos = await prisma.eventos.upsert({
     *   create: {
     *     // ... data to create a Eventos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eventos we want to update
     *   }
     * })
    **/
    upsert<T extends eventosUpsertArgs>(
      args: SelectSubset<T, eventosUpsertArgs>
    ): CheckSelect<T, Prisma__eventosClient<eventos>, Prisma__eventosClient<eventosGetPayload<T>>>

    /**
     * Count the number of Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosCountArgs} args - Arguments to filter Eventos to count.
     * @example
     * // Count the number of Eventos
     * const count = await prisma.eventos.count({
     *   where: {
     *     // ... the filter for the Eventos we want to count
     *   }
     * })
    **/
    count<T extends eventosCountArgs>(
      args?: Subset<T, eventosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventosAggregateArgs>(args: Subset<T, EventosAggregateArgs>): PrismaPromise<GetEventosAggregateType<T>>

    /**
     * Group by Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventosGroupByArgs['orderBy'] }
        : { orderBy?: EventosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for eventos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eventosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cliente<T extends clienteArgs = {}>(args?: Subset<T, clienteArgs>): CheckSelect<T, Prisma__clienteClient<cliente | null >, Prisma__clienteClient<clienteGetPayload<T> | null >>;

    paqueteevento<T extends paqueteeventoArgs = {}>(args?: Subset<T, paqueteeventoArgs>): CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento | null >, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T> | null >>;

    gastoseventos<T extends gastoseventosFindManyArgs = {}>(args?: Subset<T, gastoseventosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<gastoseventos>>, PrismaPromise<Array<gastoseventosGetPayload<T>>>>;

    pagos<T extends pagosFindManyArgs = {}>(args?: Subset<T, pagosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<pagos>>, PrismaPromise<Array<pagosGetPayload<T>>>>;

    servicioseventos<T extends servicioseventosFindManyArgs = {}>(args?: Subset<T, servicioseventosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<servicioseventos>>, PrismaPromise<Array<servicioseventosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * eventos findUnique
   */
  export type eventosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
    /**
     * Throw an Error if a eventos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which eventos to fetch.
     * 
    **/
    where: eventosWhereUniqueInput
  }


  /**
   * eventos findFirst
   */
  export type eventosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
    /**
     * Throw an Error if a eventos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which eventos to fetch.
     * 
    **/
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     * 
    **/
    orderBy?: Enumerable<eventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventos.
     * 
    **/
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventos.
     * 
    **/
    distinct?: Enumerable<EventosScalarFieldEnum>
  }


  /**
   * eventos findMany
   */
  export type eventosFindManyArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
    /**
     * Filter, which eventos to fetch.
     * 
    **/
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     * 
    **/
    orderBy?: Enumerable<eventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eventos.
     * 
    **/
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EventosScalarFieldEnum>
  }


  /**
   * eventos create
   */
  export type eventosCreateArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
    /**
     * The data needed to create a eventos.
     * 
    **/
    data: XOR<eventosCreateInput, eventosUncheckedCreateInput>
  }


  /**
   * eventos createMany
   */
  export type eventosCreateManyArgs = {
    data: Enumerable<eventosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * eventos update
   */
  export type eventosUpdateArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
    /**
     * The data needed to update a eventos.
     * 
    **/
    data: XOR<eventosUpdateInput, eventosUncheckedUpdateInput>
    /**
     * Choose, which eventos to update.
     * 
    **/
    where: eventosWhereUniqueInput
  }


  /**
   * eventos updateMany
   */
  export type eventosUpdateManyArgs = {
    data: XOR<eventosUpdateManyMutationInput, eventosUncheckedUpdateManyInput>
    where?: eventosWhereInput
  }


  /**
   * eventos upsert
   */
  export type eventosUpsertArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
    /**
     * The filter to search for the eventos to update in case it exists.
     * 
    **/
    where: eventosWhereUniqueInput
    /**
     * In case the eventos found by the `where` argument doesn't exist, create a new eventos with this data.
     * 
    **/
    create: XOR<eventosCreateInput, eventosUncheckedCreateInput>
    /**
     * In case the eventos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<eventosUpdateInput, eventosUncheckedUpdateInput>
  }


  /**
   * eventos delete
   */
  export type eventosDeleteArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
    /**
     * Filter which eventos to delete.
     * 
    **/
    where: eventosWhereUniqueInput
  }


  /**
   * eventos deleteMany
   */
  export type eventosDeleteManyArgs = {
    where?: eventosWhereInput
  }


  /**
   * eventos without action
   */
  export type eventosArgs = {
    /**
     * Select specific fields to fetch from the eventos
     * 
    **/
    select?: eventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: eventosInclude | null
  }



  /**
   * Model paquete
   */


  export type AggregatePaquete = {
    _count: PaqueteCountAggregateOutputType | null
    count: PaqueteCountAggregateOutputType | null
    _avg: PaqueteAvgAggregateOutputType | null
    avg: PaqueteAvgAggregateOutputType | null
    _sum: PaqueteSumAggregateOutputType | null
    sum: PaqueteSumAggregateOutputType | null
    _min: PaqueteMinAggregateOutputType | null
    min: PaqueteMinAggregateOutputType | null
    _max: PaqueteMaxAggregateOutputType | null
    max: PaqueteMaxAggregateOutputType | null
  }

  export type PaqueteAvgAggregateOutputType = {
    id: number | null
    adultos: number | null
    ninios: number | null
    precio: number | null
    preciounitario: number | null
  }

  export type PaqueteSumAggregateOutputType = {
    id: number | null
    adultos: number | null
    ninios: number | null
    precio: number | null
    preciounitario: number | null
  }

  export type PaqueteMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    adultos: number | null
    ninios: number | null
    precio: number | null
    preciounitario: number | null
  }

  export type PaqueteMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    adultos: number | null
    ninios: number | null
    precio: number | null
    preciounitario: number | null
  }

  export type PaqueteCountAggregateOutputType = {
    id: number
    nombre: number
    adultos: number
    ninios: number
    precio: number
    preciounitario: number
    _all: number
  }


  export type PaqueteAvgAggregateInputType = {
    id?: true
    adultos?: true
    ninios?: true
    precio?: true
    preciounitario?: true
  }

  export type PaqueteSumAggregateInputType = {
    id?: true
    adultos?: true
    ninios?: true
    precio?: true
    preciounitario?: true
  }

  export type PaqueteMinAggregateInputType = {
    id?: true
    nombre?: true
    adultos?: true
    ninios?: true
    precio?: true
    preciounitario?: true
  }

  export type PaqueteMaxAggregateInputType = {
    id?: true
    nombre?: true
    adultos?: true
    ninios?: true
    precio?: true
    preciounitario?: true
  }

  export type PaqueteCountAggregateInputType = {
    id?: true
    nombre?: true
    adultos?: true
    ninios?: true
    precio?: true
    preciounitario?: true
    _all?: true
  }

  export type PaqueteAggregateArgs = {
    /**
     * Filter which paquete to aggregate.
     * 
    **/
    where?: paqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paquetes to fetch.
     * 
    **/
    orderBy?: Enumerable<paqueteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: paqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paquetes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paquetes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paquetes
    **/
    _count?: true | PaqueteCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | PaqueteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaqueteAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: PaqueteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaqueteSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: PaqueteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaqueteMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: PaqueteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaqueteMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: PaqueteMaxAggregateInputType
  }

  export type GetPaqueteAggregateType<T extends PaqueteAggregateArgs> = {
        [P in keyof T & keyof AggregatePaquete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaquete[P]>
      : GetScalarType<T[P], AggregatePaquete[P]>
  }


    
    
  export type PaqueteGroupByArgs = {
    where?: paqueteWhereInput
    orderBy?: Enumerable<paqueteOrderByInput>
    by: Array<PaqueteScalarFieldEnum>
    having?: paqueteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaqueteCountAggregateInputType | true
    _avg?: PaqueteAvgAggregateInputType
    _sum?: PaqueteSumAggregateInputType
    _min?: PaqueteMinAggregateInputType
    _max?: PaqueteMaxAggregateInputType
  }


  export type PaqueteGroupByOutputType = {
    id: number
    nombre: string | null
    adultos: number | null
    ninios: number | null
    precio: number | null
    preciounitario: number | null
    _count: PaqueteCountAggregateOutputType | null
    _avg: PaqueteAvgAggregateOutputType | null
    _sum: PaqueteSumAggregateOutputType | null
    _min: PaqueteMinAggregateOutputType | null
    _max: PaqueteMaxAggregateOutputType | null
  }

  type GetPaqueteGroupByPayload<T extends PaqueteGroupByArgs> = Promise<
    Array<
      PickArray<PaqueteGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PaqueteGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PaqueteGroupByOutputType[P]> 
            : GetScalarType<T[P], PaqueteGroupByOutputType[P]>
        }
      > 
    >


  export type paqueteSelect = {
    id?: boolean
    nombre?: boolean
    adultos?: boolean
    ninios?: boolean
    precio?: boolean
    preciounitario?: boolean
    paqueteevento?: boolean | paqueteeventoFindManyArgs
  }

  export type paqueteInclude = {
    paqueteevento?: boolean | paqueteeventoFindManyArgs
  }

  export type paqueteGetPayload<
    S extends boolean | null | undefined | paqueteArgs,
    U = keyof S
      > = S extends true
        ? paquete
    : S extends undefined
    ? never
    : S extends paqueteArgs | paqueteFindManyArgs
    ?'include' extends U
    ? paquete  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'paqueteevento'
        ? Array < paqueteeventoGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof paquete ?paquete [P]
  : 
          P extends 'paqueteevento'
        ? Array < paqueteeventoGetPayload<S['select'][P]>>  : never
  } 
    : paquete
  : paquete


  type paqueteCountArgs = Merge<
    Omit<paqueteFindManyArgs, 'select' | 'include'> & {
      select?: PaqueteCountAggregateInputType | true
    }
  >

  export interface paqueteDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Paquete that matches the filter.
     * @param {paqueteFindUniqueArgs} args - Arguments to find a Paquete
     * @example
     * // Get one Paquete
     * const paquete = await prisma.paquete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paqueteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paqueteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'paquete'> extends True ? CheckSelect<T, Prisma__paqueteClient<paquete>, Prisma__paqueteClient<paqueteGetPayload<T>>> : CheckSelect<T, Prisma__paqueteClient<paquete | null >, Prisma__paqueteClient<paqueteGetPayload<T> | null >>

    /**
     * Find the first Paquete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteFindFirstArgs} args - Arguments to find a Paquete
     * @example
     * // Get one Paquete
     * const paquete = await prisma.paquete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paqueteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paqueteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'paquete'> extends True ? CheckSelect<T, Prisma__paqueteClient<paquete>, Prisma__paqueteClient<paqueteGetPayload<T>>> : CheckSelect<T, Prisma__paqueteClient<paquete | null >, Prisma__paqueteClient<paqueteGetPayload<T> | null >>

    /**
     * Find zero or more Paquetes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paquetes
     * const paquetes = await prisma.paquete.findMany()
     * 
     * // Get first 10 Paquetes
     * const paquetes = await prisma.paquete.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paqueteWithIdOnly = await prisma.paquete.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends paqueteFindManyArgs>(
      args?: SelectSubset<T, paqueteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<paquete>>, PrismaPromise<Array<paqueteGetPayload<T>>>>

    /**
     * Create a Paquete.
     * @param {paqueteCreateArgs} args - Arguments to create a Paquete.
     * @example
     * // Create one Paquete
     * const Paquete = await prisma.paquete.create({
     *   data: {
     *     // ... data to create a Paquete
     *   }
     * })
     * 
    **/
    create<T extends paqueteCreateArgs>(
      args: SelectSubset<T, paqueteCreateArgs>
    ): CheckSelect<T, Prisma__paqueteClient<paquete>, Prisma__paqueteClient<paqueteGetPayload<T>>>

    /**
     * Create many Paquetes.
     *     @param {paqueteCreateManyArgs} args - Arguments to create many Paquetes.
     *     @example
     *     // Create many Paquetes
     *     const paquete = await prisma.paquete.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paqueteCreateManyArgs>(
      args?: SelectSubset<T, paqueteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Paquete.
     * @param {paqueteDeleteArgs} args - Arguments to delete one Paquete.
     * @example
     * // Delete one Paquete
     * const Paquete = await prisma.paquete.delete({
     *   where: {
     *     // ... filter to delete one Paquete
     *   }
     * })
     * 
    **/
    delete<T extends paqueteDeleteArgs>(
      args: SelectSubset<T, paqueteDeleteArgs>
    ): CheckSelect<T, Prisma__paqueteClient<paquete>, Prisma__paqueteClient<paqueteGetPayload<T>>>

    /**
     * Update one Paquete.
     * @param {paqueteUpdateArgs} args - Arguments to update one Paquete.
     * @example
     * // Update one Paquete
     * const paquete = await prisma.paquete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paqueteUpdateArgs>(
      args: SelectSubset<T, paqueteUpdateArgs>
    ): CheckSelect<T, Prisma__paqueteClient<paquete>, Prisma__paqueteClient<paqueteGetPayload<T>>>

    /**
     * Delete zero or more Paquetes.
     * @param {paqueteDeleteManyArgs} args - Arguments to filter Paquetes to delete.
     * @example
     * // Delete a few Paquetes
     * const { count } = await prisma.paquete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paqueteDeleteManyArgs>(
      args?: SelectSubset<T, paqueteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paquetes
     * const paquete = await prisma.paquete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paqueteUpdateManyArgs>(
      args: SelectSubset<T, paqueteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Paquete.
     * @param {paqueteUpsertArgs} args - Arguments to update or create a Paquete.
     * @example
     * // Update or create a Paquete
     * const paquete = await prisma.paquete.upsert({
     *   create: {
     *     // ... data to create a Paquete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paquete we want to update
     *   }
     * })
    **/
    upsert<T extends paqueteUpsertArgs>(
      args: SelectSubset<T, paqueteUpsertArgs>
    ): CheckSelect<T, Prisma__paqueteClient<paquete>, Prisma__paqueteClient<paqueteGetPayload<T>>>

    /**
     * Count the number of Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteCountArgs} args - Arguments to filter Paquetes to count.
     * @example
     * // Count the number of Paquetes
     * const count = await prisma.paquete.count({
     *   where: {
     *     // ... the filter for the Paquetes we want to count
     *   }
     * })
    **/
    count<T extends paqueteCountArgs>(
      args?: Subset<T, paqueteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaqueteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paquete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaqueteAggregateArgs>(args: Subset<T, PaqueteAggregateArgs>): PrismaPromise<GetPaqueteAggregateType<T>>

    /**
     * Group by Paquete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaqueteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaqueteGroupByArgs['orderBy'] }
        : { orderBy?: PaqueteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaqueteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaqueteGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for paquete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paqueteClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    paqueteevento<T extends paqueteeventoFindManyArgs = {}>(args?: Subset<T, paqueteeventoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<paqueteevento>>, PrismaPromise<Array<paqueteeventoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * paquete findUnique
   */
  export type paqueteFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
    /**
     * Throw an Error if a paquete can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which paquete to fetch.
     * 
    **/
    where: paqueteWhereUniqueInput
  }


  /**
   * paquete findFirst
   */
  export type paqueteFindFirstArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
    /**
     * Throw an Error if a paquete can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which paquete to fetch.
     * 
    **/
    where?: paqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paquetes to fetch.
     * 
    **/
    orderBy?: Enumerable<paqueteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paquetes.
     * 
    **/
    cursor?: paqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paquetes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paquetes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paquetes.
     * 
    **/
    distinct?: Enumerable<PaqueteScalarFieldEnum>
  }


  /**
   * paquete findMany
   */
  export type paqueteFindManyArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
    /**
     * Filter, which paquetes to fetch.
     * 
    **/
    where?: paqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paquetes to fetch.
     * 
    **/
    orderBy?: Enumerable<paqueteOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paquetes.
     * 
    **/
    cursor?: paqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paquetes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paquetes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaqueteScalarFieldEnum>
  }


  /**
   * paquete create
   */
  export type paqueteCreateArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
    /**
     * The data needed to create a paquete.
     * 
    **/
    data: XOR<paqueteCreateInput, paqueteUncheckedCreateInput>
  }


  /**
   * paquete createMany
   */
  export type paqueteCreateManyArgs = {
    data: Enumerable<paqueteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * paquete update
   */
  export type paqueteUpdateArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
    /**
     * The data needed to update a paquete.
     * 
    **/
    data: XOR<paqueteUpdateInput, paqueteUncheckedUpdateInput>
    /**
     * Choose, which paquete to update.
     * 
    **/
    where: paqueteWhereUniqueInput
  }


  /**
   * paquete updateMany
   */
  export type paqueteUpdateManyArgs = {
    data: XOR<paqueteUpdateManyMutationInput, paqueteUncheckedUpdateManyInput>
    where?: paqueteWhereInput
  }


  /**
   * paquete upsert
   */
  export type paqueteUpsertArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
    /**
     * The filter to search for the paquete to update in case it exists.
     * 
    **/
    where: paqueteWhereUniqueInput
    /**
     * In case the paquete found by the `where` argument doesn't exist, create a new paquete with this data.
     * 
    **/
    create: XOR<paqueteCreateInput, paqueteUncheckedCreateInput>
    /**
     * In case the paquete was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<paqueteUpdateInput, paqueteUncheckedUpdateInput>
  }


  /**
   * paquete delete
   */
  export type paqueteDeleteArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
    /**
     * Filter which paquete to delete.
     * 
    **/
    where: paqueteWhereUniqueInput
  }


  /**
   * paquete deleteMany
   */
  export type paqueteDeleteManyArgs = {
    where?: paqueteWhereInput
  }


  /**
   * paquete without action
   */
  export type paqueteArgs = {
    /**
     * Select specific fields to fetch from the paquete
     * 
    **/
    select?: paqueteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteInclude | null
  }



  /**
   * Model paqueteevento
   */


  export type AggregatePaqueteevento = {
    _count: PaqueteeventoCountAggregateOutputType | null
    count: PaqueteeventoCountAggregateOutputType | null
    _avg: PaqueteeventoAvgAggregateOutputType | null
    avg: PaqueteeventoAvgAggregateOutputType | null
    _sum: PaqueteeventoSumAggregateOutputType | null
    sum: PaqueteeventoSumAggregateOutputType | null
    _min: PaqueteeventoMinAggregateOutputType | null
    min: PaqueteeventoMinAggregateOutputType | null
    _max: PaqueteeventoMaxAggregateOutputType | null
    max: PaqueteeventoMaxAggregateOutputType | null
  }

  export type PaqueteeventoAvgAggregateOutputType = {
    id: number | null
    adultos: number | null
    ninios: number | null
    total: number | null
    idpaquete: number | null
  }

  export type PaqueteeventoSumAggregateOutputType = {
    id: number | null
    adultos: number | null
    ninios: number | null
    total: number | null
    idpaquete: number | null
  }

  export type PaqueteeventoMinAggregateOutputType = {
    id: number | null
    adultos: number | null
    ninios: number | null
    total: number | null
    idpaquete: number | null
  }

  export type PaqueteeventoMaxAggregateOutputType = {
    id: number | null
    adultos: number | null
    ninios: number | null
    total: number | null
    idpaquete: number | null
  }

  export type PaqueteeventoCountAggregateOutputType = {
    id: number
    adultos: number
    ninios: number
    total: number
    idpaquete: number
    _all: number
  }


  export type PaqueteeventoAvgAggregateInputType = {
    id?: true
    adultos?: true
    ninios?: true
    total?: true
    idpaquete?: true
  }

  export type PaqueteeventoSumAggregateInputType = {
    id?: true
    adultos?: true
    ninios?: true
    total?: true
    idpaquete?: true
  }

  export type PaqueteeventoMinAggregateInputType = {
    id?: true
    adultos?: true
    ninios?: true
    total?: true
    idpaquete?: true
  }

  export type PaqueteeventoMaxAggregateInputType = {
    id?: true
    adultos?: true
    ninios?: true
    total?: true
    idpaquete?: true
  }

  export type PaqueteeventoCountAggregateInputType = {
    id?: true
    adultos?: true
    ninios?: true
    total?: true
    idpaquete?: true
    _all?: true
  }

  export type PaqueteeventoAggregateArgs = {
    /**
     * Filter which paqueteevento to aggregate.
     * 
    **/
    where?: paqueteeventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paqueteeventos to fetch.
     * 
    **/
    orderBy?: Enumerable<paqueteeventoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: paqueteeventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paqueteeventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paqueteeventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paqueteeventos
    **/
    _count?: true | PaqueteeventoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | PaqueteeventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaqueteeventoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: PaqueteeventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaqueteeventoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: PaqueteeventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaqueteeventoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: PaqueteeventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaqueteeventoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: PaqueteeventoMaxAggregateInputType
  }

  export type GetPaqueteeventoAggregateType<T extends PaqueteeventoAggregateArgs> = {
        [P in keyof T & keyof AggregatePaqueteevento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaqueteevento[P]>
      : GetScalarType<T[P], AggregatePaqueteevento[P]>
  }


    
    
  export type PaqueteeventoGroupByArgs = {
    where?: paqueteeventoWhereInput
    orderBy?: Enumerable<paqueteeventoOrderByInput>
    by: Array<PaqueteeventoScalarFieldEnum>
    having?: paqueteeventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaqueteeventoCountAggregateInputType | true
    _avg?: PaqueteeventoAvgAggregateInputType
    _sum?: PaqueteeventoSumAggregateInputType
    _min?: PaqueteeventoMinAggregateInputType
    _max?: PaqueteeventoMaxAggregateInputType
  }


  export type PaqueteeventoGroupByOutputType = {
    id: number
    adultos: number | null
    ninios: number | null
    total: number | null
    idpaquete: number | null
    _count: PaqueteeventoCountAggregateOutputType | null
    _avg: PaqueteeventoAvgAggregateOutputType | null
    _sum: PaqueteeventoSumAggregateOutputType | null
    _min: PaqueteeventoMinAggregateOutputType | null
    _max: PaqueteeventoMaxAggregateOutputType | null
  }

  type GetPaqueteeventoGroupByPayload<T extends PaqueteeventoGroupByArgs> = Promise<
    Array<
      PickArray<PaqueteeventoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PaqueteeventoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PaqueteeventoGroupByOutputType[P]> 
            : GetScalarType<T[P], PaqueteeventoGroupByOutputType[P]>
        }
      > 
    >


  export type paqueteeventoSelect = {
    id?: boolean
    adultos?: boolean
    ninios?: boolean
    total?: boolean
    idpaquete?: boolean
    paquete?: boolean | paqueteArgs
    eventos?: boolean | eventosFindManyArgs
  }

  export type paqueteeventoInclude = {
    paquete?: boolean | paqueteArgs
    eventos?: boolean | eventosFindManyArgs
  }

  export type paqueteeventoGetPayload<
    S extends boolean | null | undefined | paqueteeventoArgs,
    U = keyof S
      > = S extends true
        ? paqueteevento
    : S extends undefined
    ? never
    : S extends paqueteeventoArgs | paqueteeventoFindManyArgs
    ?'include' extends U
    ? paqueteevento  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'paquete'
        ? paqueteGetPayload<S['include'][P]> | null :
        P extends 'eventos'
        ? Array < eventosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof paqueteevento ?paqueteevento [P]
  : 
          P extends 'paquete'
        ? paqueteGetPayload<S['select'][P]> | null :
        P extends 'eventos'
        ? Array < eventosGetPayload<S['select'][P]>>  : never
  } 
    : paqueteevento
  : paqueteevento


  type paqueteeventoCountArgs = Merge<
    Omit<paqueteeventoFindManyArgs, 'select' | 'include'> & {
      select?: PaqueteeventoCountAggregateInputType | true
    }
  >

  export interface paqueteeventoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Paqueteevento that matches the filter.
     * @param {paqueteeventoFindUniqueArgs} args - Arguments to find a Paqueteevento
     * @example
     * // Get one Paqueteevento
     * const paqueteevento = await prisma.paqueteevento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paqueteeventoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paqueteeventoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'paqueteevento'> extends True ? CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento>, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T>>> : CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento | null >, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T> | null >>

    /**
     * Find the first Paqueteevento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteeventoFindFirstArgs} args - Arguments to find a Paqueteevento
     * @example
     * // Get one Paqueteevento
     * const paqueteevento = await prisma.paqueteevento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paqueteeventoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paqueteeventoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'paqueteevento'> extends True ? CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento>, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T>>> : CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento | null >, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T> | null >>

    /**
     * Find zero or more Paqueteeventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteeventoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paqueteeventos
     * const paqueteeventos = await prisma.paqueteevento.findMany()
     * 
     * // Get first 10 Paqueteeventos
     * const paqueteeventos = await prisma.paqueteevento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paqueteeventoWithIdOnly = await prisma.paqueteevento.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends paqueteeventoFindManyArgs>(
      args?: SelectSubset<T, paqueteeventoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<paqueteevento>>, PrismaPromise<Array<paqueteeventoGetPayload<T>>>>

    /**
     * Create a Paqueteevento.
     * @param {paqueteeventoCreateArgs} args - Arguments to create a Paqueteevento.
     * @example
     * // Create one Paqueteevento
     * const Paqueteevento = await prisma.paqueteevento.create({
     *   data: {
     *     // ... data to create a Paqueteevento
     *   }
     * })
     * 
    **/
    create<T extends paqueteeventoCreateArgs>(
      args: SelectSubset<T, paqueteeventoCreateArgs>
    ): CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento>, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T>>>

    /**
     * Create many Paqueteeventos.
     *     @param {paqueteeventoCreateManyArgs} args - Arguments to create many Paqueteeventos.
     *     @example
     *     // Create many Paqueteeventos
     *     const paqueteevento = await prisma.paqueteevento.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paqueteeventoCreateManyArgs>(
      args?: SelectSubset<T, paqueteeventoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Paqueteevento.
     * @param {paqueteeventoDeleteArgs} args - Arguments to delete one Paqueteevento.
     * @example
     * // Delete one Paqueteevento
     * const Paqueteevento = await prisma.paqueteevento.delete({
     *   where: {
     *     // ... filter to delete one Paqueteevento
     *   }
     * })
     * 
    **/
    delete<T extends paqueteeventoDeleteArgs>(
      args: SelectSubset<T, paqueteeventoDeleteArgs>
    ): CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento>, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T>>>

    /**
     * Update one Paqueteevento.
     * @param {paqueteeventoUpdateArgs} args - Arguments to update one Paqueteevento.
     * @example
     * // Update one Paqueteevento
     * const paqueteevento = await prisma.paqueteevento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paqueteeventoUpdateArgs>(
      args: SelectSubset<T, paqueteeventoUpdateArgs>
    ): CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento>, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T>>>

    /**
     * Delete zero or more Paqueteeventos.
     * @param {paqueteeventoDeleteManyArgs} args - Arguments to filter Paqueteeventos to delete.
     * @example
     * // Delete a few Paqueteeventos
     * const { count } = await prisma.paqueteevento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paqueteeventoDeleteManyArgs>(
      args?: SelectSubset<T, paqueteeventoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paqueteeventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteeventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paqueteeventos
     * const paqueteevento = await prisma.paqueteevento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paqueteeventoUpdateManyArgs>(
      args: SelectSubset<T, paqueteeventoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Paqueteevento.
     * @param {paqueteeventoUpsertArgs} args - Arguments to update or create a Paqueteevento.
     * @example
     * // Update or create a Paqueteevento
     * const paqueteevento = await prisma.paqueteevento.upsert({
     *   create: {
     *     // ... data to create a Paqueteevento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paqueteevento we want to update
     *   }
     * })
    **/
    upsert<T extends paqueteeventoUpsertArgs>(
      args: SelectSubset<T, paqueteeventoUpsertArgs>
    ): CheckSelect<T, Prisma__paqueteeventoClient<paqueteevento>, Prisma__paqueteeventoClient<paqueteeventoGetPayload<T>>>

    /**
     * Count the number of Paqueteeventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paqueteeventoCountArgs} args - Arguments to filter Paqueteeventos to count.
     * @example
     * // Count the number of Paqueteeventos
     * const count = await prisma.paqueteevento.count({
     *   where: {
     *     // ... the filter for the Paqueteeventos we want to count
     *   }
     * })
    **/
    count<T extends paqueteeventoCountArgs>(
      args?: Subset<T, paqueteeventoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaqueteeventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paqueteevento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteeventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaqueteeventoAggregateArgs>(args: Subset<T, PaqueteeventoAggregateArgs>): PrismaPromise<GetPaqueteeventoAggregateType<T>>

    /**
     * Group by Paqueteevento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteeventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaqueteeventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaqueteeventoGroupByArgs['orderBy'] }
        : { orderBy?: PaqueteeventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaqueteeventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaqueteeventoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for paqueteevento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paqueteeventoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    paquete<T extends paqueteArgs = {}>(args?: Subset<T, paqueteArgs>): CheckSelect<T, Prisma__paqueteClient<paquete | null >, Prisma__paqueteClient<paqueteGetPayload<T> | null >>;

    eventos<T extends eventosFindManyArgs = {}>(args?: Subset<T, eventosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<eventos>>, PrismaPromise<Array<eventosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * paqueteevento findUnique
   */
  export type paqueteeventoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
    /**
     * Throw an Error if a paqueteevento can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which paqueteevento to fetch.
     * 
    **/
    where: paqueteeventoWhereUniqueInput
  }


  /**
   * paqueteevento findFirst
   */
  export type paqueteeventoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
    /**
     * Throw an Error if a paqueteevento can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which paqueteevento to fetch.
     * 
    **/
    where?: paqueteeventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paqueteeventos to fetch.
     * 
    **/
    orderBy?: Enumerable<paqueteeventoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paqueteeventos.
     * 
    **/
    cursor?: paqueteeventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paqueteeventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paqueteeventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paqueteeventos.
     * 
    **/
    distinct?: Enumerable<PaqueteeventoScalarFieldEnum>
  }


  /**
   * paqueteevento findMany
   */
  export type paqueteeventoFindManyArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
    /**
     * Filter, which paqueteeventos to fetch.
     * 
    **/
    where?: paqueteeventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paqueteeventos to fetch.
     * 
    **/
    orderBy?: Enumerable<paqueteeventoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paqueteeventos.
     * 
    **/
    cursor?: paqueteeventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paqueteeventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paqueteeventos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaqueteeventoScalarFieldEnum>
  }


  /**
   * paqueteevento create
   */
  export type paqueteeventoCreateArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
    /**
     * The data needed to create a paqueteevento.
     * 
    **/
    data: XOR<paqueteeventoCreateInput, paqueteeventoUncheckedCreateInput>
  }


  /**
   * paqueteevento createMany
   */
  export type paqueteeventoCreateManyArgs = {
    data: Enumerable<paqueteeventoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * paqueteevento update
   */
  export type paqueteeventoUpdateArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
    /**
     * The data needed to update a paqueteevento.
     * 
    **/
    data: XOR<paqueteeventoUpdateInput, paqueteeventoUncheckedUpdateInput>
    /**
     * Choose, which paqueteevento to update.
     * 
    **/
    where: paqueteeventoWhereUniqueInput
  }


  /**
   * paqueteevento updateMany
   */
  export type paqueteeventoUpdateManyArgs = {
    data: XOR<paqueteeventoUpdateManyMutationInput, paqueteeventoUncheckedUpdateManyInput>
    where?: paqueteeventoWhereInput
  }


  /**
   * paqueteevento upsert
   */
  export type paqueteeventoUpsertArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
    /**
     * The filter to search for the paqueteevento to update in case it exists.
     * 
    **/
    where: paqueteeventoWhereUniqueInput
    /**
     * In case the paqueteevento found by the `where` argument doesn't exist, create a new paqueteevento with this data.
     * 
    **/
    create: XOR<paqueteeventoCreateInput, paqueteeventoUncheckedCreateInput>
    /**
     * In case the paqueteevento was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<paqueteeventoUpdateInput, paqueteeventoUncheckedUpdateInput>
  }


  /**
   * paqueteevento delete
   */
  export type paqueteeventoDeleteArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
    /**
     * Filter which paqueteevento to delete.
     * 
    **/
    where: paqueteeventoWhereUniqueInput
  }


  /**
   * paqueteevento deleteMany
   */
  export type paqueteeventoDeleteManyArgs = {
    where?: paqueteeventoWhereInput
  }


  /**
   * paqueteevento without action
   */
  export type paqueteeventoArgs = {
    /**
     * Select specific fields to fetch from the paqueteevento
     * 
    **/
    select?: paqueteeventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paqueteeventoInclude | null
  }



  /**
   * Model abono
   */


  export type AggregateAbono = {
    _count: AbonoCountAggregateOutputType | null
    count: AbonoCountAggregateOutputType | null
    _avg: AbonoAvgAggregateOutputType | null
    avg: AbonoAvgAggregateOutputType | null
    _sum: AbonoSumAggregateOutputType | null
    sum: AbonoSumAggregateOutputType | null
    _min: AbonoMinAggregateOutputType | null
    min: AbonoMinAggregateOutputType | null
    _max: AbonoMaxAggregateOutputType | null
    max: AbonoMaxAggregateOutputType | null
  }

  export type AbonoAvgAggregateOutputType = {
    id: number | null
    cantidad: number | null
    idcliente: number | null
    idpagos: number | null
  }

  export type AbonoSumAggregateOutputType = {
    id: number | null
    cantidad: number | null
    idcliente: number | null
    idpagos: number | null
  }

  export type AbonoMinAggregateOutputType = {
    id: number | null
    fecha: Date | null
    cantidad: number | null
    idcliente: number | null
    idpagos: number | null
  }

  export type AbonoMaxAggregateOutputType = {
    id: number | null
    fecha: Date | null
    cantidad: number | null
    idcliente: number | null
    idpagos: number | null
  }

  export type AbonoCountAggregateOutputType = {
    id: number
    fecha: number
    cantidad: number
    idcliente: number
    idpagos: number
    _all: number
  }


  export type AbonoAvgAggregateInputType = {
    id?: true
    cantidad?: true
    idcliente?: true
    idpagos?: true
  }

  export type AbonoSumAggregateInputType = {
    id?: true
    cantidad?: true
    idcliente?: true
    idpagos?: true
  }

  export type AbonoMinAggregateInputType = {
    id?: true
    fecha?: true
    cantidad?: true
    idcliente?: true
    idpagos?: true
  }

  export type AbonoMaxAggregateInputType = {
    id?: true
    fecha?: true
    cantidad?: true
    idcliente?: true
    idpagos?: true
  }

  export type AbonoCountAggregateInputType = {
    id?: true
    fecha?: true
    cantidad?: true
    idcliente?: true
    idpagos?: true
    _all?: true
  }

  export type AbonoAggregateArgs = {
    /**
     * Filter which abono to aggregate.
     * 
    **/
    where?: abonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abonos to fetch.
     * 
    **/
    orderBy?: Enumerable<abonoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: abonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abonos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abonos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned abonos
    **/
    _count?: true | AbonoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AbonoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbonoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: AbonoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbonoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: AbonoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbonoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AbonoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbonoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AbonoMaxAggregateInputType
  }

  export type GetAbonoAggregateType<T extends AbonoAggregateArgs> = {
        [P in keyof T & keyof AggregateAbono]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbono[P]>
      : GetScalarType<T[P], AggregateAbono[P]>
  }


    
    
  export type AbonoGroupByArgs = {
    where?: abonoWhereInput
    orderBy?: Enumerable<abonoOrderByInput>
    by: Array<AbonoScalarFieldEnum>
    having?: abonoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbonoCountAggregateInputType | true
    _avg?: AbonoAvgAggregateInputType
    _sum?: AbonoSumAggregateInputType
    _min?: AbonoMinAggregateInputType
    _max?: AbonoMaxAggregateInputType
  }


  export type AbonoGroupByOutputType = {
    id: number
    fecha: Date | null
    cantidad: number | null
    idcliente: number | null
    idpagos: number | null
    _count: AbonoCountAggregateOutputType | null
    _avg: AbonoAvgAggregateOutputType | null
    _sum: AbonoSumAggregateOutputType | null
    _min: AbonoMinAggregateOutputType | null
    _max: AbonoMaxAggregateOutputType | null
  }

  type GetAbonoGroupByPayload<T extends AbonoGroupByArgs> = Promise<
    Array<
      PickArray<AbonoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AbonoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AbonoGroupByOutputType[P]> 
            : GetScalarType<T[P], AbonoGroupByOutputType[P]>
        }
      > 
    >


  export type abonoSelect = {
    id?: boolean
    fecha?: boolean
    cantidad?: boolean
    idcliente?: boolean
    idpagos?: boolean
    cliente?: boolean | clienteArgs
    pagos?: boolean | pagosArgs
  }

  export type abonoInclude = {
    cliente?: boolean | clienteArgs
    pagos?: boolean | pagosArgs
  }

  export type abonoGetPayload<
    S extends boolean | null | undefined | abonoArgs,
    U = keyof S
      > = S extends true
        ? abono
    : S extends undefined
    ? never
    : S extends abonoArgs | abonoFindManyArgs
    ?'include' extends U
    ? abono  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'cliente'
        ? clienteGetPayload<S['include'][P]> | null :
        P extends 'pagos'
        ? pagosGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof abono ?abono [P]
  : 
          P extends 'cliente'
        ? clienteGetPayload<S['select'][P]> | null :
        P extends 'pagos'
        ? pagosGetPayload<S['select'][P]> | null : never
  } 
    : abono
  : abono


  type abonoCountArgs = Merge<
    Omit<abonoFindManyArgs, 'select' | 'include'> & {
      select?: AbonoCountAggregateInputType | true
    }
  >

  export interface abonoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Abono that matches the filter.
     * @param {abonoFindUniqueArgs} args - Arguments to find a Abono
     * @example
     * // Get one Abono
     * const abono = await prisma.abono.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends abonoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, abonoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'abono'> extends True ? CheckSelect<T, Prisma__abonoClient<abono>, Prisma__abonoClient<abonoGetPayload<T>>> : CheckSelect<T, Prisma__abonoClient<abono | null >, Prisma__abonoClient<abonoGetPayload<T> | null >>

    /**
     * Find the first Abono that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonoFindFirstArgs} args - Arguments to find a Abono
     * @example
     * // Get one Abono
     * const abono = await prisma.abono.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends abonoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, abonoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'abono'> extends True ? CheckSelect<T, Prisma__abonoClient<abono>, Prisma__abonoClient<abonoGetPayload<T>>> : CheckSelect<T, Prisma__abonoClient<abono | null >, Prisma__abonoClient<abonoGetPayload<T> | null >>

    /**
     * Find zero or more Abonos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abonos
     * const abonos = await prisma.abono.findMany()
     * 
     * // Get first 10 Abonos
     * const abonos = await prisma.abono.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abonoWithIdOnly = await prisma.abono.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends abonoFindManyArgs>(
      args?: SelectSubset<T, abonoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<abono>>, PrismaPromise<Array<abonoGetPayload<T>>>>

    /**
     * Create a Abono.
     * @param {abonoCreateArgs} args - Arguments to create a Abono.
     * @example
     * // Create one Abono
     * const Abono = await prisma.abono.create({
     *   data: {
     *     // ... data to create a Abono
     *   }
     * })
     * 
    **/
    create<T extends abonoCreateArgs>(
      args: SelectSubset<T, abonoCreateArgs>
    ): CheckSelect<T, Prisma__abonoClient<abono>, Prisma__abonoClient<abonoGetPayload<T>>>

    /**
     * Create many Abonos.
     *     @param {abonoCreateManyArgs} args - Arguments to create many Abonos.
     *     @example
     *     // Create many Abonos
     *     const abono = await prisma.abono.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends abonoCreateManyArgs>(
      args?: SelectSubset<T, abonoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Abono.
     * @param {abonoDeleteArgs} args - Arguments to delete one Abono.
     * @example
     * // Delete one Abono
     * const Abono = await prisma.abono.delete({
     *   where: {
     *     // ... filter to delete one Abono
     *   }
     * })
     * 
    **/
    delete<T extends abonoDeleteArgs>(
      args: SelectSubset<T, abonoDeleteArgs>
    ): CheckSelect<T, Prisma__abonoClient<abono>, Prisma__abonoClient<abonoGetPayload<T>>>

    /**
     * Update one Abono.
     * @param {abonoUpdateArgs} args - Arguments to update one Abono.
     * @example
     * // Update one Abono
     * const abono = await prisma.abono.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends abonoUpdateArgs>(
      args: SelectSubset<T, abonoUpdateArgs>
    ): CheckSelect<T, Prisma__abonoClient<abono>, Prisma__abonoClient<abonoGetPayload<T>>>

    /**
     * Delete zero or more Abonos.
     * @param {abonoDeleteManyArgs} args - Arguments to filter Abonos to delete.
     * @example
     * // Delete a few Abonos
     * const { count } = await prisma.abono.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends abonoDeleteManyArgs>(
      args?: SelectSubset<T, abonoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abonos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abonos
     * const abono = await prisma.abono.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends abonoUpdateManyArgs>(
      args: SelectSubset<T, abonoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Abono.
     * @param {abonoUpsertArgs} args - Arguments to update or create a Abono.
     * @example
     * // Update or create a Abono
     * const abono = await prisma.abono.upsert({
     *   create: {
     *     // ... data to create a Abono
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Abono we want to update
     *   }
     * })
    **/
    upsert<T extends abonoUpsertArgs>(
      args: SelectSubset<T, abonoUpsertArgs>
    ): CheckSelect<T, Prisma__abonoClient<abono>, Prisma__abonoClient<abonoGetPayload<T>>>

    /**
     * Count the number of Abonos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonoCountArgs} args - Arguments to filter Abonos to count.
     * @example
     * // Count the number of Abonos
     * const count = await prisma.abono.count({
     *   where: {
     *     // ... the filter for the Abonos we want to count
     *   }
     * })
    **/
    count<T extends abonoCountArgs>(
      args?: Subset<T, abonoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbonoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Abono.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbonoAggregateArgs>(args: Subset<T, AbonoAggregateArgs>): PrismaPromise<GetAbonoAggregateType<T>>

    /**
     * Group by Abono.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbonoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbonoGroupByArgs['orderBy'] }
        : { orderBy?: AbonoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbonoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbonoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for abono.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__abonoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cliente<T extends clienteArgs = {}>(args?: Subset<T, clienteArgs>): CheckSelect<T, Prisma__clienteClient<cliente | null >, Prisma__clienteClient<clienteGetPayload<T> | null >>;

    pagos<T extends pagosArgs = {}>(args?: Subset<T, pagosArgs>): CheckSelect<T, Prisma__pagosClient<pagos | null >, Prisma__pagosClient<pagosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * abono findUnique
   */
  export type abonoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
    /**
     * Throw an Error if a abono can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which abono to fetch.
     * 
    **/
    where: abonoWhereUniqueInput
  }


  /**
   * abono findFirst
   */
  export type abonoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
    /**
     * Throw an Error if a abono can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which abono to fetch.
     * 
    **/
    where?: abonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abonos to fetch.
     * 
    **/
    orderBy?: Enumerable<abonoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for abonos.
     * 
    **/
    cursor?: abonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abonos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abonos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of abonos.
     * 
    **/
    distinct?: Enumerable<AbonoScalarFieldEnum>
  }


  /**
   * abono findMany
   */
  export type abonoFindManyArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
    /**
     * Filter, which abonos to fetch.
     * 
    **/
    where?: abonoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abonos to fetch.
     * 
    **/
    orderBy?: Enumerable<abonoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing abonos.
     * 
    **/
    cursor?: abonoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abonos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abonos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AbonoScalarFieldEnum>
  }


  /**
   * abono create
   */
  export type abonoCreateArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
    /**
     * The data needed to create a abono.
     * 
    **/
    data: XOR<abonoCreateInput, abonoUncheckedCreateInput>
  }


  /**
   * abono createMany
   */
  export type abonoCreateManyArgs = {
    data: Enumerable<abonoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * abono update
   */
  export type abonoUpdateArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
    /**
     * The data needed to update a abono.
     * 
    **/
    data: XOR<abonoUpdateInput, abonoUncheckedUpdateInput>
    /**
     * Choose, which abono to update.
     * 
    **/
    where: abonoWhereUniqueInput
  }


  /**
   * abono updateMany
   */
  export type abonoUpdateManyArgs = {
    data: XOR<abonoUpdateManyMutationInput, abonoUncheckedUpdateManyInput>
    where?: abonoWhereInput
  }


  /**
   * abono upsert
   */
  export type abonoUpsertArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
    /**
     * The filter to search for the abono to update in case it exists.
     * 
    **/
    where: abonoWhereUniqueInput
    /**
     * In case the abono found by the `where` argument doesn't exist, create a new abono with this data.
     * 
    **/
    create: XOR<abonoCreateInput, abonoUncheckedCreateInput>
    /**
     * In case the abono was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<abonoUpdateInput, abonoUncheckedUpdateInput>
  }


  /**
   * abono delete
   */
  export type abonoDeleteArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
    /**
     * Filter which abono to delete.
     * 
    **/
    where: abonoWhereUniqueInput
  }


  /**
   * abono deleteMany
   */
  export type abonoDeleteManyArgs = {
    where?: abonoWhereInput
  }


  /**
   * abono without action
   */
  export type abonoArgs = {
    /**
     * Select specific fields to fetch from the abono
     * 
    **/
    select?: abonoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: abonoInclude | null
  }



  /**
   * Model empleados
   */


  export type AggregateEmpleados = {
    _count: EmpleadosCountAggregateOutputType | null
    count: EmpleadosCountAggregateOutputType | null
    _avg: EmpleadosAvgAggregateOutputType | null
    avg: EmpleadosAvgAggregateOutputType | null
    _sum: EmpleadosSumAggregateOutputType | null
    sum: EmpleadosSumAggregateOutputType | null
    _min: EmpleadosMinAggregateOutputType | null
    min: EmpleadosMinAggregateOutputType | null
    _max: EmpleadosMaxAggregateOutputType | null
    max: EmpleadosMaxAggregateOutputType | null
  }

  export type EmpleadosAvgAggregateOutputType = {
    id: number | null
    telefono: number | null
    idrol: number | null
  }

  export type EmpleadosSumAggregateOutputType = {
    id: number | null
    telefono: number | null
    idrol: number | null
  }

  export type EmpleadosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    direccion: string | null
    telefono: number | null
    descripcion: string | null
    idrol: number | null
  }

  export type EmpleadosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    direccion: string | null
    telefono: number | null
    descripcion: string | null
    idrol: number | null
  }

  export type EmpleadosCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    direccion: number
    telefono: number
    descripcion: number
    idrol: number
    _all: number
  }


  export type EmpleadosAvgAggregateInputType = {
    id?: true
    telefono?: true
    idrol?: true
  }

  export type EmpleadosSumAggregateInputType = {
    id?: true
    telefono?: true
    idrol?: true
  }

  export type EmpleadosMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    direccion?: true
    telefono?: true
    descripcion?: true
    idrol?: true
  }

  export type EmpleadosMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    direccion?: true
    telefono?: true
    descripcion?: true
    idrol?: true
  }

  export type EmpleadosCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    direccion?: true
    telefono?: true
    descripcion?: true
    idrol?: true
    _all?: true
  }

  export type EmpleadosAggregateArgs = {
    /**
     * Filter which empleados to aggregate.
     * 
    **/
    where?: empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empleados
    **/
    _count?: true | EmpleadosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | EmpleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpleadosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: EmpleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpleadosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: EmpleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: EmpleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: EmpleadosMaxAggregateInputType
  }

  export type GetEmpleadosAggregateType<T extends EmpleadosAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleados[P]>
      : GetScalarType<T[P], AggregateEmpleados[P]>
  }


    
    
  export type EmpleadosGroupByArgs = {
    where?: empleadosWhereInput
    orderBy?: Enumerable<empleadosOrderByInput>
    by: Array<EmpleadosScalarFieldEnum>
    having?: empleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadosCountAggregateInputType | true
    _avg?: EmpleadosAvgAggregateInputType
    _sum?: EmpleadosSumAggregateInputType
    _min?: EmpleadosMinAggregateInputType
    _max?: EmpleadosMaxAggregateInputType
  }


  export type EmpleadosGroupByOutputType = {
    id: number
    nombre: string | null
    apellido: string | null
    direccion: string | null
    telefono: number | null
    descripcion: string | null
    idrol: number | null
    _count: EmpleadosCountAggregateOutputType | null
    _avg: EmpleadosAvgAggregateOutputType | null
    _sum: EmpleadosSumAggregateOutputType | null
    _min: EmpleadosMinAggregateOutputType | null
    _max: EmpleadosMaxAggregateOutputType | null
  }

  type GetEmpleadosGroupByPayload<T extends EmpleadosGroupByArgs> = Promise<
    Array<
      PickArray<EmpleadosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof EmpleadosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], EmpleadosGroupByOutputType[P]> 
            : GetScalarType<T[P], EmpleadosGroupByOutputType[P]>
        }
      > 
    >


  export type empleadosSelect = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    direccion?: boolean
    telefono?: boolean
    descripcion?: boolean
    idrol?: boolean
    rol?: boolean | rolArgs
    servicioseventos?: boolean | servicioseventosFindManyArgs
  }

  export type empleadosInclude = {
    rol?: boolean | rolArgs
    servicioseventos?: boolean | servicioseventosFindManyArgs
  }

  export type empleadosGetPayload<
    S extends boolean | null | undefined | empleadosArgs,
    U = keyof S
      > = S extends true
        ? empleados
    : S extends undefined
    ? never
    : S extends empleadosArgs | empleadosFindManyArgs
    ?'include' extends U
    ? empleados  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'rol'
        ? rolGetPayload<S['include'][P]> | null :
        P extends 'servicioseventos'
        ? Array < servicioseventosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof empleados ?empleados [P]
  : 
          P extends 'rol'
        ? rolGetPayload<S['select'][P]> | null :
        P extends 'servicioseventos'
        ? Array < servicioseventosGetPayload<S['select'][P]>>  : never
  } 
    : empleados
  : empleados


  type empleadosCountArgs = Merge<
    Omit<empleadosFindManyArgs, 'select' | 'include'> & {
      select?: EmpleadosCountAggregateInputType | true
    }
  >

  export interface empleadosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Empleados that matches the filter.
     * @param {empleadosFindUniqueArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empleadosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, empleadosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'empleados'> extends True ? CheckSelect<T, Prisma__empleadosClient<empleados>, Prisma__empleadosClient<empleadosGetPayload<T>>> : CheckSelect<T, Prisma__empleadosClient<empleados | null >, Prisma__empleadosClient<empleadosGetPayload<T> | null >>

    /**
     * Find the first Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosFindFirstArgs} args - Arguments to find a Empleados
     * @example
     * // Get one Empleados
     * const empleados = await prisma.empleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empleadosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, empleadosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'empleados'> extends True ? CheckSelect<T, Prisma__empleadosClient<empleados>, Prisma__empleadosClient<empleadosGetPayload<T>>> : CheckSelect<T, Prisma__empleadosClient<empleados | null >, Prisma__empleadosClient<empleadosGetPayload<T> | null >>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleados.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empleadosWithIdOnly = await prisma.empleados.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends empleadosFindManyArgs>(
      args?: SelectSubset<T, empleadosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<empleados>>, PrismaPromise<Array<empleadosGetPayload<T>>>>

    /**
     * Create a Empleados.
     * @param {empleadosCreateArgs} args - Arguments to create a Empleados.
     * @example
     * // Create one Empleados
     * const Empleados = await prisma.empleados.create({
     *   data: {
     *     // ... data to create a Empleados
     *   }
     * })
     * 
    **/
    create<T extends empleadosCreateArgs>(
      args: SelectSubset<T, empleadosCreateArgs>
    ): CheckSelect<T, Prisma__empleadosClient<empleados>, Prisma__empleadosClient<empleadosGetPayload<T>>>

    /**
     * Create many Empleados.
     *     @param {empleadosCreateManyArgs} args - Arguments to create many Empleados.
     *     @example
     *     // Create many Empleados
     *     const empleados = await prisma.empleados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empleadosCreateManyArgs>(
      args?: SelectSubset<T, empleadosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Empleados.
     * @param {empleadosDeleteArgs} args - Arguments to delete one Empleados.
     * @example
     * // Delete one Empleados
     * const Empleados = await prisma.empleados.delete({
     *   where: {
     *     // ... filter to delete one Empleados
     *   }
     * })
     * 
    **/
    delete<T extends empleadosDeleteArgs>(
      args: SelectSubset<T, empleadosDeleteArgs>
    ): CheckSelect<T, Prisma__empleadosClient<empleados>, Prisma__empleadosClient<empleadosGetPayload<T>>>

    /**
     * Update one Empleados.
     * @param {empleadosUpdateArgs} args - Arguments to update one Empleados.
     * @example
     * // Update one Empleados
     * const empleados = await prisma.empleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empleadosUpdateArgs>(
      args: SelectSubset<T, empleadosUpdateArgs>
    ): CheckSelect<T, Prisma__empleadosClient<empleados>, Prisma__empleadosClient<empleadosGetPayload<T>>>

    /**
     * Delete zero or more Empleados.
     * @param {empleadosDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empleadosDeleteManyArgs>(
      args?: SelectSubset<T, empleadosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleados = await prisma.empleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empleadosUpdateManyArgs>(
      args: SelectSubset<T, empleadosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleados.
     * @param {empleadosUpsertArgs} args - Arguments to update or create a Empleados.
     * @example
     * // Update or create a Empleados
     * const empleados = await prisma.empleados.upsert({
     *   create: {
     *     // ... data to create a Empleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleados we want to update
     *   }
     * })
    **/
    upsert<T extends empleadosUpsertArgs>(
      args: SelectSubset<T, empleadosUpsertArgs>
    ): CheckSelect<T, Prisma__empleadosClient<empleados>, Prisma__empleadosClient<empleadosGetPayload<T>>>

    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadosCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleados.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends empleadosCountArgs>(
      args?: Subset<T, empleadosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadosAggregateArgs>(args: Subset<T, EmpleadosAggregateArgs>): PrismaPromise<GetEmpleadosAggregateType<T>>

    /**
     * Group by Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadosGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for empleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__empleadosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    rol<T extends rolArgs = {}>(args?: Subset<T, rolArgs>): CheckSelect<T, Prisma__rolClient<rol | null >, Prisma__rolClient<rolGetPayload<T> | null >>;

    servicioseventos<T extends servicioseventosFindManyArgs = {}>(args?: Subset<T, servicioseventosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<servicioseventos>>, PrismaPromise<Array<servicioseventosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * empleados findUnique
   */
  export type empleadosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
    /**
     * Throw an Error if a empleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empleados to fetch.
     * 
    **/
    where: empleadosWhereUniqueInput
  }


  /**
   * empleados findFirst
   */
  export type empleadosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
    /**
     * Throw an Error if a empleados can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which empleados to fetch.
     * 
    **/
    where?: empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     * 
    **/
    cursor?: empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     * 
    **/
    distinct?: Enumerable<EmpleadosScalarFieldEnum>
  }


  /**
   * empleados findMany
   */
  export type empleadosFindManyArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
    /**
     * Filter, which empleados to fetch.
     * 
    **/
    where?: empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     * 
    **/
    orderBy?: Enumerable<empleadosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empleados.
     * 
    **/
    cursor?: empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmpleadosScalarFieldEnum>
  }


  /**
   * empleados create
   */
  export type empleadosCreateArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
    /**
     * The data needed to create a empleados.
     * 
    **/
    data: XOR<empleadosCreateInput, empleadosUncheckedCreateInput>
  }


  /**
   * empleados createMany
   */
  export type empleadosCreateManyArgs = {
    data: Enumerable<empleadosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * empleados update
   */
  export type empleadosUpdateArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
    /**
     * The data needed to update a empleados.
     * 
    **/
    data: XOR<empleadosUpdateInput, empleadosUncheckedUpdateInput>
    /**
     * Choose, which empleados to update.
     * 
    **/
    where: empleadosWhereUniqueInput
  }


  /**
   * empleados updateMany
   */
  export type empleadosUpdateManyArgs = {
    data: XOR<empleadosUpdateManyMutationInput, empleadosUncheckedUpdateManyInput>
    where?: empleadosWhereInput
  }


  /**
   * empleados upsert
   */
  export type empleadosUpsertArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
    /**
     * The filter to search for the empleados to update in case it exists.
     * 
    **/
    where: empleadosWhereUniqueInput
    /**
     * In case the empleados found by the `where` argument doesn't exist, create a new empleados with this data.
     * 
    **/
    create: XOR<empleadosCreateInput, empleadosUncheckedCreateInput>
    /**
     * In case the empleados was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<empleadosUpdateInput, empleadosUncheckedUpdateInput>
  }


  /**
   * empleados delete
   */
  export type empleadosDeleteArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
    /**
     * Filter which empleados to delete.
     * 
    **/
    where: empleadosWhereUniqueInput
  }


  /**
   * empleados deleteMany
   */
  export type empleadosDeleteManyArgs = {
    where?: empleadosWhereInput
  }


  /**
   * empleados without action
   */
  export type empleadosArgs = {
    /**
     * Select specific fields to fetch from the empleados
     * 
    **/
    select?: empleadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: empleadosInclude | null
  }



  /**
   * Model gastofijo
   */


  export type AggregateGastofijo = {
    _count: GastofijoCountAggregateOutputType | null
    count: GastofijoCountAggregateOutputType | null
    _avg: GastofijoAvgAggregateOutputType | null
    avg: GastofijoAvgAggregateOutputType | null
    _sum: GastofijoSumAggregateOutputType | null
    sum: GastofijoSumAggregateOutputType | null
    _min: GastofijoMinAggregateOutputType | null
    min: GastofijoMinAggregateOutputType | null
    _max: GastofijoMaxAggregateOutputType | null
    max: GastofijoMaxAggregateOutputType | null
  }

  export type GastofijoAvgAggregateOutputType = {
    id: number | null
    total: number | null
    idmes: number | null
  }

  export type GastofijoSumAggregateOutputType = {
    id: number | null
    total: number | null
    idmes: number | null
  }

  export type GastofijoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    total: number | null
    activo: boolean | null
    idmes: number | null
  }

  export type GastofijoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    total: number | null
    activo: boolean | null
    idmes: number | null
  }

  export type GastofijoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    total: number
    activo: number
    idmes: number
    _all: number
  }


  export type GastofijoAvgAggregateInputType = {
    id?: true
    total?: true
    idmes?: true
  }

  export type GastofijoSumAggregateInputType = {
    id?: true
    total?: true
    idmes?: true
  }

  export type GastofijoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    total?: true
    activo?: true
    idmes?: true
  }

  export type GastofijoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    total?: true
    activo?: true
    idmes?: true
  }

  export type GastofijoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    total?: true
    activo?: true
    idmes?: true
    _all?: true
  }

  export type GastofijoAggregateArgs = {
    /**
     * Filter which gastofijo to aggregate.
     * 
    **/
    where?: gastofijoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastofijos to fetch.
     * 
    **/
    orderBy?: Enumerable<gastofijoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: gastofijoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastofijos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastofijos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gastofijos
    **/
    _count?: true | GastofijoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | GastofijoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GastofijoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: GastofijoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GastofijoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: GastofijoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GastofijoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: GastofijoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GastofijoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: GastofijoMaxAggregateInputType
  }

  export type GetGastofijoAggregateType<T extends GastofijoAggregateArgs> = {
        [P in keyof T & keyof AggregateGastofijo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGastofijo[P]>
      : GetScalarType<T[P], AggregateGastofijo[P]>
  }


    
    
  export type GastofijoGroupByArgs = {
    where?: gastofijoWhereInput
    orderBy?: Enumerable<gastofijoOrderByInput>
    by: Array<GastofijoScalarFieldEnum>
    having?: gastofijoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GastofijoCountAggregateInputType | true
    _avg?: GastofijoAvgAggregateInputType
    _sum?: GastofijoSumAggregateInputType
    _min?: GastofijoMinAggregateInputType
    _max?: GastofijoMaxAggregateInputType
  }


  export type GastofijoGroupByOutputType = {
    id: number
    nombre: string | null
    descripcion: string | null
    total: number | null
    activo: boolean | null
    idmes: number | null
    _count: GastofijoCountAggregateOutputType | null
    _avg: GastofijoAvgAggregateOutputType | null
    _sum: GastofijoSumAggregateOutputType | null
    _min: GastofijoMinAggregateOutputType | null
    _max: GastofijoMaxAggregateOutputType | null
  }

  type GetGastofijoGroupByPayload<T extends GastofijoGroupByArgs> = Promise<
    Array<
      PickArray<GastofijoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GastofijoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GastofijoGroupByOutputType[P]> 
            : GetScalarType<T[P], GastofijoGroupByOutputType[P]>
        }
      > 
    >


  export type gastofijoSelect = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    total?: boolean
    activo?: boolean
    idmes?: boolean
  }

  export type gastofijoGetPayload<
    S extends boolean | null | undefined | gastofijoArgs,
    U = keyof S
      > = S extends true
        ? gastofijo
    : S extends undefined
    ? never
    : S extends gastofijoArgs | gastofijoFindManyArgs
    ?'include' extends U
    ? gastofijo 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof gastofijo ?gastofijo [P]
  : 
     never
  } 
    : gastofijo
  : gastofijo


  type gastofijoCountArgs = Merge<
    Omit<gastofijoFindManyArgs, 'select' | 'include'> & {
      select?: GastofijoCountAggregateInputType | true
    }
  >

  export interface gastofijoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Gastofijo that matches the filter.
     * @param {gastofijoFindUniqueArgs} args - Arguments to find a Gastofijo
     * @example
     * // Get one Gastofijo
     * const gastofijo = await prisma.gastofijo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gastofijoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gastofijoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gastofijo'> extends True ? CheckSelect<T, Prisma__gastofijoClient<gastofijo>, Prisma__gastofijoClient<gastofijoGetPayload<T>>> : CheckSelect<T, Prisma__gastofijoClient<gastofijo | null >, Prisma__gastofijoClient<gastofijoGetPayload<T> | null >>

    /**
     * Find the first Gastofijo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastofijoFindFirstArgs} args - Arguments to find a Gastofijo
     * @example
     * // Get one Gastofijo
     * const gastofijo = await prisma.gastofijo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gastofijoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gastofijoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gastofijo'> extends True ? CheckSelect<T, Prisma__gastofijoClient<gastofijo>, Prisma__gastofijoClient<gastofijoGetPayload<T>>> : CheckSelect<T, Prisma__gastofijoClient<gastofijo | null >, Prisma__gastofijoClient<gastofijoGetPayload<T> | null >>

    /**
     * Find zero or more Gastofijos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastofijoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gastofijos
     * const gastofijos = await prisma.gastofijo.findMany()
     * 
     * // Get first 10 Gastofijos
     * const gastofijos = await prisma.gastofijo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gastofijoWithIdOnly = await prisma.gastofijo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends gastofijoFindManyArgs>(
      args?: SelectSubset<T, gastofijoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<gastofijo>>, PrismaPromise<Array<gastofijoGetPayload<T>>>>

    /**
     * Create a Gastofijo.
     * @param {gastofijoCreateArgs} args - Arguments to create a Gastofijo.
     * @example
     * // Create one Gastofijo
     * const Gastofijo = await prisma.gastofijo.create({
     *   data: {
     *     // ... data to create a Gastofijo
     *   }
     * })
     * 
    **/
    create<T extends gastofijoCreateArgs>(
      args: SelectSubset<T, gastofijoCreateArgs>
    ): CheckSelect<T, Prisma__gastofijoClient<gastofijo>, Prisma__gastofijoClient<gastofijoGetPayload<T>>>

    /**
     * Create many Gastofijos.
     *     @param {gastofijoCreateManyArgs} args - Arguments to create many Gastofijos.
     *     @example
     *     // Create many Gastofijos
     *     const gastofijo = await prisma.gastofijo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gastofijoCreateManyArgs>(
      args?: SelectSubset<T, gastofijoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Gastofijo.
     * @param {gastofijoDeleteArgs} args - Arguments to delete one Gastofijo.
     * @example
     * // Delete one Gastofijo
     * const Gastofijo = await prisma.gastofijo.delete({
     *   where: {
     *     // ... filter to delete one Gastofijo
     *   }
     * })
     * 
    **/
    delete<T extends gastofijoDeleteArgs>(
      args: SelectSubset<T, gastofijoDeleteArgs>
    ): CheckSelect<T, Prisma__gastofijoClient<gastofijo>, Prisma__gastofijoClient<gastofijoGetPayload<T>>>

    /**
     * Update one Gastofijo.
     * @param {gastofijoUpdateArgs} args - Arguments to update one Gastofijo.
     * @example
     * // Update one Gastofijo
     * const gastofijo = await prisma.gastofijo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gastofijoUpdateArgs>(
      args: SelectSubset<T, gastofijoUpdateArgs>
    ): CheckSelect<T, Prisma__gastofijoClient<gastofijo>, Prisma__gastofijoClient<gastofijoGetPayload<T>>>

    /**
     * Delete zero or more Gastofijos.
     * @param {gastofijoDeleteManyArgs} args - Arguments to filter Gastofijos to delete.
     * @example
     * // Delete a few Gastofijos
     * const { count } = await prisma.gastofijo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gastofijoDeleteManyArgs>(
      args?: SelectSubset<T, gastofijoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gastofijos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastofijoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gastofijos
     * const gastofijo = await prisma.gastofijo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gastofijoUpdateManyArgs>(
      args: SelectSubset<T, gastofijoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Gastofijo.
     * @param {gastofijoUpsertArgs} args - Arguments to update or create a Gastofijo.
     * @example
     * // Update or create a Gastofijo
     * const gastofijo = await prisma.gastofijo.upsert({
     *   create: {
     *     // ... data to create a Gastofijo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gastofijo we want to update
     *   }
     * })
    **/
    upsert<T extends gastofijoUpsertArgs>(
      args: SelectSubset<T, gastofijoUpsertArgs>
    ): CheckSelect<T, Prisma__gastofijoClient<gastofijo>, Prisma__gastofijoClient<gastofijoGetPayload<T>>>

    /**
     * Count the number of Gastofijos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastofijoCountArgs} args - Arguments to filter Gastofijos to count.
     * @example
     * // Count the number of Gastofijos
     * const count = await prisma.gastofijo.count({
     *   where: {
     *     // ... the filter for the Gastofijos we want to count
     *   }
     * })
    **/
    count<T extends gastofijoCountArgs>(
      args?: Subset<T, gastofijoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GastofijoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gastofijo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastofijoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GastofijoAggregateArgs>(args: Subset<T, GastofijoAggregateArgs>): PrismaPromise<GetGastofijoAggregateType<T>>

    /**
     * Group by Gastofijo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastofijoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GastofijoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GastofijoGroupByArgs['orderBy'] }
        : { orderBy?: GastofijoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GastofijoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGastofijoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for gastofijo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gastofijoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * gastofijo findUnique
   */
  export type gastofijoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
    /**
     * Throw an Error if a gastofijo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which gastofijo to fetch.
     * 
    **/
    where: gastofijoWhereUniqueInput
  }


  /**
   * gastofijo findFirst
   */
  export type gastofijoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
    /**
     * Throw an Error if a gastofijo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which gastofijo to fetch.
     * 
    **/
    where?: gastofijoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastofijos to fetch.
     * 
    **/
    orderBy?: Enumerable<gastofijoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastofijos.
     * 
    **/
    cursor?: gastofijoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastofijos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastofijos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastofijos.
     * 
    **/
    distinct?: Enumerable<GastofijoScalarFieldEnum>
  }


  /**
   * gastofijo findMany
   */
  export type gastofijoFindManyArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
    /**
     * Filter, which gastofijos to fetch.
     * 
    **/
    where?: gastofijoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastofijos to fetch.
     * 
    **/
    orderBy?: Enumerable<gastofijoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gastofijos.
     * 
    **/
    cursor?: gastofijoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastofijos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastofijos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GastofijoScalarFieldEnum>
  }


  /**
   * gastofijo create
   */
  export type gastofijoCreateArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
    /**
     * The data needed to create a gastofijo.
     * 
    **/
    data: XOR<gastofijoCreateInput, gastofijoUncheckedCreateInput>
  }


  /**
   * gastofijo createMany
   */
  export type gastofijoCreateManyArgs = {
    data: Enumerable<gastofijoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gastofijo update
   */
  export type gastofijoUpdateArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
    /**
     * The data needed to update a gastofijo.
     * 
    **/
    data: XOR<gastofijoUpdateInput, gastofijoUncheckedUpdateInput>
    /**
     * Choose, which gastofijo to update.
     * 
    **/
    where: gastofijoWhereUniqueInput
  }


  /**
   * gastofijo updateMany
   */
  export type gastofijoUpdateManyArgs = {
    data: XOR<gastofijoUpdateManyMutationInput, gastofijoUncheckedUpdateManyInput>
    where?: gastofijoWhereInput
  }


  /**
   * gastofijo upsert
   */
  export type gastofijoUpsertArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
    /**
     * The filter to search for the gastofijo to update in case it exists.
     * 
    **/
    where: gastofijoWhereUniqueInput
    /**
     * In case the gastofijo found by the `where` argument doesn't exist, create a new gastofijo with this data.
     * 
    **/
    create: XOR<gastofijoCreateInput, gastofijoUncheckedCreateInput>
    /**
     * In case the gastofijo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<gastofijoUpdateInput, gastofijoUncheckedUpdateInput>
  }


  /**
   * gastofijo delete
   */
  export type gastofijoDeleteArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
    /**
     * Filter which gastofijo to delete.
     * 
    **/
    where: gastofijoWhereUniqueInput
  }


  /**
   * gastofijo deleteMany
   */
  export type gastofijoDeleteManyArgs = {
    where?: gastofijoWhereInput
  }


  /**
   * gastofijo without action
   */
  export type gastofijoArgs = {
    /**
     * Select specific fields to fetch from the gastofijo
     * 
    **/
    select?: gastofijoSelect | null
  }



  /**
   * Model gastoseventos
   */


  export type AggregateGastoseventos = {
    _count: GastoseventosCountAggregateOutputType | null
    count: GastoseventosCountAggregateOutputType | null
    _avg: GastoseventosAvgAggregateOutputType | null
    avg: GastoseventosAvgAggregateOutputType | null
    _sum: GastoseventosSumAggregateOutputType | null
    sum: GastoseventosSumAggregateOutputType | null
    _min: GastoseventosMinAggregateOutputType | null
    min: GastoseventosMinAggregateOutputType | null
    _max: GastoseventosMaxAggregateOutputType | null
    max: GastoseventosMaxAggregateOutputType | null
  }

  export type GastoseventosAvgAggregateOutputType = {
    id: number | null
    monto: number | null
    idmes: number | null
    idevento: number | null
  }

  export type GastoseventosSumAggregateOutputType = {
    id: number | null
    monto: number | null
    idmes: number | null
    idevento: number | null
  }

  export type GastoseventosMinAggregateOutputType = {
    id: number | null
    monto: number | null
    motivo: string | null
    descripcion: string | null
    idmes: number | null
    idevento: number | null
  }

  export type GastoseventosMaxAggregateOutputType = {
    id: number | null
    monto: number | null
    motivo: string | null
    descripcion: string | null
    idmes: number | null
    idevento: number | null
  }

  export type GastoseventosCountAggregateOutputType = {
    id: number
    monto: number
    motivo: number
    descripcion: number
    idmes: number
    idevento: number
    _all: number
  }


  export type GastoseventosAvgAggregateInputType = {
    id?: true
    monto?: true
    idmes?: true
    idevento?: true
  }

  export type GastoseventosSumAggregateInputType = {
    id?: true
    monto?: true
    idmes?: true
    idevento?: true
  }

  export type GastoseventosMinAggregateInputType = {
    id?: true
    monto?: true
    motivo?: true
    descripcion?: true
    idmes?: true
    idevento?: true
  }

  export type GastoseventosMaxAggregateInputType = {
    id?: true
    monto?: true
    motivo?: true
    descripcion?: true
    idmes?: true
    idevento?: true
  }

  export type GastoseventosCountAggregateInputType = {
    id?: true
    monto?: true
    motivo?: true
    descripcion?: true
    idmes?: true
    idevento?: true
    _all?: true
  }

  export type GastoseventosAggregateArgs = {
    /**
     * Filter which gastoseventos to aggregate.
     * 
    **/
    where?: gastoseventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastoseventos to fetch.
     * 
    **/
    orderBy?: Enumerable<gastoseventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: gastoseventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastoseventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastoseventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gastoseventos
    **/
    _count?: true | GastoseventosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | GastoseventosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GastoseventosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: GastoseventosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GastoseventosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: GastoseventosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GastoseventosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: GastoseventosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GastoseventosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: GastoseventosMaxAggregateInputType
  }

  export type GetGastoseventosAggregateType<T extends GastoseventosAggregateArgs> = {
        [P in keyof T & keyof AggregateGastoseventos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGastoseventos[P]>
      : GetScalarType<T[P], AggregateGastoseventos[P]>
  }


    
    
  export type GastoseventosGroupByArgs = {
    where?: gastoseventosWhereInput
    orderBy?: Enumerable<gastoseventosOrderByInput>
    by: Array<GastoseventosScalarFieldEnum>
    having?: gastoseventosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GastoseventosCountAggregateInputType | true
    _avg?: GastoseventosAvgAggregateInputType
    _sum?: GastoseventosSumAggregateInputType
    _min?: GastoseventosMinAggregateInputType
    _max?: GastoseventosMaxAggregateInputType
  }


  export type GastoseventosGroupByOutputType = {
    id: number
    monto: number | null
    motivo: string | null
    descripcion: string | null
    idmes: number | null
    idevento: number | null
    _count: GastoseventosCountAggregateOutputType | null
    _avg: GastoseventosAvgAggregateOutputType | null
    _sum: GastoseventosSumAggregateOutputType | null
    _min: GastoseventosMinAggregateOutputType | null
    _max: GastoseventosMaxAggregateOutputType | null
  }

  type GetGastoseventosGroupByPayload<T extends GastoseventosGroupByArgs> = Promise<
    Array<
      PickArray<GastoseventosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GastoseventosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GastoseventosGroupByOutputType[P]> 
            : GetScalarType<T[P], GastoseventosGroupByOutputType[P]>
        }
      > 
    >


  export type gastoseventosSelect = {
    id?: boolean
    monto?: boolean
    motivo?: boolean
    descripcion?: boolean
    idmes?: boolean
    idevento?: boolean
    eventos?: boolean | eventosArgs
    mes?: boolean | mesArgs
  }

  export type gastoseventosInclude = {
    eventos?: boolean | eventosArgs
    mes?: boolean | mesArgs
  }

  export type gastoseventosGetPayload<
    S extends boolean | null | undefined | gastoseventosArgs,
    U = keyof S
      > = S extends true
        ? gastoseventos
    : S extends undefined
    ? never
    : S extends gastoseventosArgs | gastoseventosFindManyArgs
    ?'include' extends U
    ? gastoseventos  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'eventos'
        ? eventosGetPayload<S['include'][P]> | null :
        P extends 'mes'
        ? mesGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof gastoseventos ?gastoseventos [P]
  : 
          P extends 'eventos'
        ? eventosGetPayload<S['select'][P]> | null :
        P extends 'mes'
        ? mesGetPayload<S['select'][P]> | null : never
  } 
    : gastoseventos
  : gastoseventos


  type gastoseventosCountArgs = Merge<
    Omit<gastoseventosFindManyArgs, 'select' | 'include'> & {
      select?: GastoseventosCountAggregateInputType | true
    }
  >

  export interface gastoseventosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Gastoseventos that matches the filter.
     * @param {gastoseventosFindUniqueArgs} args - Arguments to find a Gastoseventos
     * @example
     * // Get one Gastoseventos
     * const gastoseventos = await prisma.gastoseventos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gastoseventosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gastoseventosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gastoseventos'> extends True ? CheckSelect<T, Prisma__gastoseventosClient<gastoseventos>, Prisma__gastoseventosClient<gastoseventosGetPayload<T>>> : CheckSelect<T, Prisma__gastoseventosClient<gastoseventos | null >, Prisma__gastoseventosClient<gastoseventosGetPayload<T> | null >>

    /**
     * Find the first Gastoseventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastoseventosFindFirstArgs} args - Arguments to find a Gastoseventos
     * @example
     * // Get one Gastoseventos
     * const gastoseventos = await prisma.gastoseventos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gastoseventosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gastoseventosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gastoseventos'> extends True ? CheckSelect<T, Prisma__gastoseventosClient<gastoseventos>, Prisma__gastoseventosClient<gastoseventosGetPayload<T>>> : CheckSelect<T, Prisma__gastoseventosClient<gastoseventos | null >, Prisma__gastoseventosClient<gastoseventosGetPayload<T> | null >>

    /**
     * Find zero or more Gastoseventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastoseventosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gastoseventos
     * const gastoseventos = await prisma.gastoseventos.findMany()
     * 
     * // Get first 10 Gastoseventos
     * const gastoseventos = await prisma.gastoseventos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gastoseventosWithIdOnly = await prisma.gastoseventos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends gastoseventosFindManyArgs>(
      args?: SelectSubset<T, gastoseventosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<gastoseventos>>, PrismaPromise<Array<gastoseventosGetPayload<T>>>>

    /**
     * Create a Gastoseventos.
     * @param {gastoseventosCreateArgs} args - Arguments to create a Gastoseventos.
     * @example
     * // Create one Gastoseventos
     * const Gastoseventos = await prisma.gastoseventos.create({
     *   data: {
     *     // ... data to create a Gastoseventos
     *   }
     * })
     * 
    **/
    create<T extends gastoseventosCreateArgs>(
      args: SelectSubset<T, gastoseventosCreateArgs>
    ): CheckSelect<T, Prisma__gastoseventosClient<gastoseventos>, Prisma__gastoseventosClient<gastoseventosGetPayload<T>>>

    /**
     * Create many Gastoseventos.
     *     @param {gastoseventosCreateManyArgs} args - Arguments to create many Gastoseventos.
     *     @example
     *     // Create many Gastoseventos
     *     const gastoseventos = await prisma.gastoseventos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gastoseventosCreateManyArgs>(
      args?: SelectSubset<T, gastoseventosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Gastoseventos.
     * @param {gastoseventosDeleteArgs} args - Arguments to delete one Gastoseventos.
     * @example
     * // Delete one Gastoseventos
     * const Gastoseventos = await prisma.gastoseventos.delete({
     *   where: {
     *     // ... filter to delete one Gastoseventos
     *   }
     * })
     * 
    **/
    delete<T extends gastoseventosDeleteArgs>(
      args: SelectSubset<T, gastoseventosDeleteArgs>
    ): CheckSelect<T, Prisma__gastoseventosClient<gastoseventos>, Prisma__gastoseventosClient<gastoseventosGetPayload<T>>>

    /**
     * Update one Gastoseventos.
     * @param {gastoseventosUpdateArgs} args - Arguments to update one Gastoseventos.
     * @example
     * // Update one Gastoseventos
     * const gastoseventos = await prisma.gastoseventos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gastoseventosUpdateArgs>(
      args: SelectSubset<T, gastoseventosUpdateArgs>
    ): CheckSelect<T, Prisma__gastoseventosClient<gastoseventos>, Prisma__gastoseventosClient<gastoseventosGetPayload<T>>>

    /**
     * Delete zero or more Gastoseventos.
     * @param {gastoseventosDeleteManyArgs} args - Arguments to filter Gastoseventos to delete.
     * @example
     * // Delete a few Gastoseventos
     * const { count } = await prisma.gastoseventos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gastoseventosDeleteManyArgs>(
      args?: SelectSubset<T, gastoseventosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gastoseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastoseventosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gastoseventos
     * const gastoseventos = await prisma.gastoseventos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gastoseventosUpdateManyArgs>(
      args: SelectSubset<T, gastoseventosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Gastoseventos.
     * @param {gastoseventosUpsertArgs} args - Arguments to update or create a Gastoseventos.
     * @example
     * // Update or create a Gastoseventos
     * const gastoseventos = await prisma.gastoseventos.upsert({
     *   create: {
     *     // ... data to create a Gastoseventos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gastoseventos we want to update
     *   }
     * })
    **/
    upsert<T extends gastoseventosUpsertArgs>(
      args: SelectSubset<T, gastoseventosUpsertArgs>
    ): CheckSelect<T, Prisma__gastoseventosClient<gastoseventos>, Prisma__gastoseventosClient<gastoseventosGetPayload<T>>>

    /**
     * Count the number of Gastoseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastoseventosCountArgs} args - Arguments to filter Gastoseventos to count.
     * @example
     * // Count the number of Gastoseventos
     * const count = await prisma.gastoseventos.count({
     *   where: {
     *     // ... the filter for the Gastoseventos we want to count
     *   }
     * })
    **/
    count<T extends gastoseventosCountArgs>(
      args?: Subset<T, gastoseventosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GastoseventosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gastoseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoseventosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GastoseventosAggregateArgs>(args: Subset<T, GastoseventosAggregateArgs>): PrismaPromise<GetGastoseventosAggregateType<T>>

    /**
     * Group by Gastoseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GastoseventosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GastoseventosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GastoseventosGroupByArgs['orderBy'] }
        : { orderBy?: GastoseventosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GastoseventosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGastoseventosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for gastoseventos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gastoseventosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    eventos<T extends eventosArgs = {}>(args?: Subset<T, eventosArgs>): CheckSelect<T, Prisma__eventosClient<eventos | null >, Prisma__eventosClient<eventosGetPayload<T> | null >>;

    mes<T extends mesArgs = {}>(args?: Subset<T, mesArgs>): CheckSelect<T, Prisma__mesClient<mes | null >, Prisma__mesClient<mesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * gastoseventos findUnique
   */
  export type gastoseventosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
    /**
     * Throw an Error if a gastoseventos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which gastoseventos to fetch.
     * 
    **/
    where: gastoseventosWhereUniqueInput
  }


  /**
   * gastoseventos findFirst
   */
  export type gastoseventosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
    /**
     * Throw an Error if a gastoseventos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which gastoseventos to fetch.
     * 
    **/
    where?: gastoseventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastoseventos to fetch.
     * 
    **/
    orderBy?: Enumerable<gastoseventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastoseventos.
     * 
    **/
    cursor?: gastoseventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastoseventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastoseventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastoseventos.
     * 
    **/
    distinct?: Enumerable<GastoseventosScalarFieldEnum>
  }


  /**
   * gastoseventos findMany
   */
  export type gastoseventosFindManyArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
    /**
     * Filter, which gastoseventos to fetch.
     * 
    **/
    where?: gastoseventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastoseventos to fetch.
     * 
    **/
    orderBy?: Enumerable<gastoseventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gastoseventos.
     * 
    **/
    cursor?: gastoseventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastoseventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastoseventos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GastoseventosScalarFieldEnum>
  }


  /**
   * gastoseventos create
   */
  export type gastoseventosCreateArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
    /**
     * The data needed to create a gastoseventos.
     * 
    **/
    data: XOR<gastoseventosCreateInput, gastoseventosUncheckedCreateInput>
  }


  /**
   * gastoseventos createMany
   */
  export type gastoseventosCreateManyArgs = {
    data: Enumerable<gastoseventosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gastoseventos update
   */
  export type gastoseventosUpdateArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
    /**
     * The data needed to update a gastoseventos.
     * 
    **/
    data: XOR<gastoseventosUpdateInput, gastoseventosUncheckedUpdateInput>
    /**
     * Choose, which gastoseventos to update.
     * 
    **/
    where: gastoseventosWhereUniqueInput
  }


  /**
   * gastoseventos updateMany
   */
  export type gastoseventosUpdateManyArgs = {
    data: XOR<gastoseventosUpdateManyMutationInput, gastoseventosUncheckedUpdateManyInput>
    where?: gastoseventosWhereInput
  }


  /**
   * gastoseventos upsert
   */
  export type gastoseventosUpsertArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
    /**
     * The filter to search for the gastoseventos to update in case it exists.
     * 
    **/
    where: gastoseventosWhereUniqueInput
    /**
     * In case the gastoseventos found by the `where` argument doesn't exist, create a new gastoseventos with this data.
     * 
    **/
    create: XOR<gastoseventosCreateInput, gastoseventosUncheckedCreateInput>
    /**
     * In case the gastoseventos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<gastoseventosUpdateInput, gastoseventosUncheckedUpdateInput>
  }


  /**
   * gastoseventos delete
   */
  export type gastoseventosDeleteArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
    /**
     * Filter which gastoseventos to delete.
     * 
    **/
    where: gastoseventosWhereUniqueInput
  }


  /**
   * gastoseventos deleteMany
   */
  export type gastoseventosDeleteManyArgs = {
    where?: gastoseventosWhereInput
  }


  /**
   * gastoseventos without action
   */
  export type gastoseventosArgs = {
    /**
     * Select specific fields to fetch from the gastoseventos
     * 
    **/
    select?: gastoseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: gastoseventosInclude | null
  }



  /**
   * Model mes
   */


  export type AggregateMes = {
    _count: MesCountAggregateOutputType | null
    count: MesCountAggregateOutputType | null
    _avg: MesAvgAggregateOutputType | null
    avg: MesAvgAggregateOutputType | null
    _sum: MesSumAggregateOutputType | null
    sum: MesSumAggregateOutputType | null
    _min: MesMinAggregateOutputType | null
    min: MesMinAggregateOutputType | null
    _max: MesMaxAggregateOutputType | null
    max: MesMaxAggregateOutputType | null
  }

  export type MesAvgAggregateOutputType = {
    id: number | null
    gastos: number | null
    ganancias: number | null
  }

  export type MesSumAggregateOutputType = {
    id: number | null
    gastos: number | null
    ganancias: number | null
  }

  export type MesMinAggregateOutputType = {
    id: number | null
    mes: Date | null
    gastos: number | null
    ganancias: number | null
  }

  export type MesMaxAggregateOutputType = {
    id: number | null
    mes: Date | null
    gastos: number | null
    ganancias: number | null
  }

  export type MesCountAggregateOutputType = {
    id: number
    mes: number
    gastos: number
    ganancias: number
    _all: number
  }


  export type MesAvgAggregateInputType = {
    id?: true
    gastos?: true
    ganancias?: true
  }

  export type MesSumAggregateInputType = {
    id?: true
    gastos?: true
    ganancias?: true
  }

  export type MesMinAggregateInputType = {
    id?: true
    mes?: true
    gastos?: true
    ganancias?: true
  }

  export type MesMaxAggregateInputType = {
    id?: true
    mes?: true
    gastos?: true
    ganancias?: true
  }

  export type MesCountAggregateInputType = {
    id?: true
    mes?: true
    gastos?: true
    ganancias?: true
    _all?: true
  }

  export type MesAggregateArgs = {
    /**
     * Filter which mes to aggregate.
     * 
    **/
    where?: mesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mes to fetch.
     * 
    **/
    orderBy?: Enumerable<mesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mes
    **/
    _count?: true | MesCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | MesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MesAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: MesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MesSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: MesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MesMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: MesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MesMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: MesMaxAggregateInputType
  }

  export type GetMesAggregateType<T extends MesAggregateArgs> = {
        [P in keyof T & keyof AggregateMes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMes[P]>
      : GetScalarType<T[P], AggregateMes[P]>
  }


    
    
  export type MesGroupByArgs = {
    where?: mesWhereInput
    orderBy?: Enumerable<mesOrderByInput>
    by: Array<MesScalarFieldEnum>
    having?: mesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MesCountAggregateInputType | true
    _avg?: MesAvgAggregateInputType
    _sum?: MesSumAggregateInputType
    _min?: MesMinAggregateInputType
    _max?: MesMaxAggregateInputType
  }


  export type MesGroupByOutputType = {
    id: number
    mes: Date | null
    gastos: number | null
    ganancias: number | null
    _count: MesCountAggregateOutputType | null
    _avg: MesAvgAggregateOutputType | null
    _sum: MesSumAggregateOutputType | null
    _min: MesMinAggregateOutputType | null
    _max: MesMaxAggregateOutputType | null
  }

  type GetMesGroupByPayload<T extends MesGroupByArgs> = Promise<
    Array<
      PickArray<MesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MesGroupByOutputType[P]> 
            : GetScalarType<T[P], MesGroupByOutputType[P]>
        }
      > 
    >


  export type mesSelect = {
    id?: boolean
    mes?: boolean
    gastos?: boolean
    ganancias?: boolean
    gastoseventos?: boolean | gastoseventosFindManyArgs
  }

  export type mesInclude = {
    gastoseventos?: boolean | gastoseventosFindManyArgs
  }

  export type mesGetPayload<
    S extends boolean | null | undefined | mesArgs,
    U = keyof S
      > = S extends true
        ? mes
    : S extends undefined
    ? never
    : S extends mesArgs | mesFindManyArgs
    ?'include' extends U
    ? mes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'gastoseventos'
        ? Array < gastoseventosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof mes ?mes [P]
  : 
          P extends 'gastoseventos'
        ? Array < gastoseventosGetPayload<S['select'][P]>>  : never
  } 
    : mes
  : mes


  type mesCountArgs = Merge<
    Omit<mesFindManyArgs, 'select' | 'include'> & {
      select?: MesCountAggregateInputType | true
    }
  >

  export interface mesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Mes that matches the filter.
     * @param {mesFindUniqueArgs} args - Arguments to find a Mes
     * @example
     * // Get one Mes
     * const mes = await prisma.mes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mes'> extends True ? CheckSelect<T, Prisma__mesClient<mes>, Prisma__mesClient<mesGetPayload<T>>> : CheckSelect<T, Prisma__mesClient<mes | null >, Prisma__mesClient<mesGetPayload<T> | null >>

    /**
     * Find the first Mes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesFindFirstArgs} args - Arguments to find a Mes
     * @example
     * // Get one Mes
     * const mes = await prisma.mes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mes'> extends True ? CheckSelect<T, Prisma__mesClient<mes>, Prisma__mesClient<mesGetPayload<T>>> : CheckSelect<T, Prisma__mesClient<mes | null >, Prisma__mesClient<mesGetPayload<T> | null >>

    /**
     * Find zero or more Mes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mes
     * const mes = await prisma.mes.findMany()
     * 
     * // Get first 10 Mes
     * const mes = await prisma.mes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mesWithIdOnly = await prisma.mes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends mesFindManyArgs>(
      args?: SelectSubset<T, mesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<mes>>, PrismaPromise<Array<mesGetPayload<T>>>>

    /**
     * Create a Mes.
     * @param {mesCreateArgs} args - Arguments to create a Mes.
     * @example
     * // Create one Mes
     * const Mes = await prisma.mes.create({
     *   data: {
     *     // ... data to create a Mes
     *   }
     * })
     * 
    **/
    create<T extends mesCreateArgs>(
      args: SelectSubset<T, mesCreateArgs>
    ): CheckSelect<T, Prisma__mesClient<mes>, Prisma__mesClient<mesGetPayload<T>>>

    /**
     * Create many Mes.
     *     @param {mesCreateManyArgs} args - Arguments to create many Mes.
     *     @example
     *     // Create many Mes
     *     const mes = await prisma.mes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mesCreateManyArgs>(
      args?: SelectSubset<T, mesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mes.
     * @param {mesDeleteArgs} args - Arguments to delete one Mes.
     * @example
     * // Delete one Mes
     * const Mes = await prisma.mes.delete({
     *   where: {
     *     // ... filter to delete one Mes
     *   }
     * })
     * 
    **/
    delete<T extends mesDeleteArgs>(
      args: SelectSubset<T, mesDeleteArgs>
    ): CheckSelect<T, Prisma__mesClient<mes>, Prisma__mesClient<mesGetPayload<T>>>

    /**
     * Update one Mes.
     * @param {mesUpdateArgs} args - Arguments to update one Mes.
     * @example
     * // Update one Mes
     * const mes = await prisma.mes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mesUpdateArgs>(
      args: SelectSubset<T, mesUpdateArgs>
    ): CheckSelect<T, Prisma__mesClient<mes>, Prisma__mesClient<mesGetPayload<T>>>

    /**
     * Delete zero or more Mes.
     * @param {mesDeleteManyArgs} args - Arguments to filter Mes to delete.
     * @example
     * // Delete a few Mes
     * const { count } = await prisma.mes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mesDeleteManyArgs>(
      args?: SelectSubset<T, mesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mes
     * const mes = await prisma.mes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mesUpdateManyArgs>(
      args: SelectSubset<T, mesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mes.
     * @param {mesUpsertArgs} args - Arguments to update or create a Mes.
     * @example
     * // Update or create a Mes
     * const mes = await prisma.mes.upsert({
     *   create: {
     *     // ... data to create a Mes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mes we want to update
     *   }
     * })
    **/
    upsert<T extends mesUpsertArgs>(
      args: SelectSubset<T, mesUpsertArgs>
    ): CheckSelect<T, Prisma__mesClient<mes>, Prisma__mesClient<mesGetPayload<T>>>

    /**
     * Count the number of Mes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesCountArgs} args - Arguments to filter Mes to count.
     * @example
     * // Count the number of Mes
     * const count = await prisma.mes.count({
     *   where: {
     *     // ... the filter for the Mes we want to count
     *   }
     * })
    **/
    count<T extends mesCountArgs>(
      args?: Subset<T, mesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MesAggregateArgs>(args: Subset<T, MesAggregateArgs>): PrismaPromise<GetMesAggregateType<T>>

    /**
     * Group by Mes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MesGroupByArgs['orderBy'] }
        : { orderBy?: MesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for mes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    gastoseventos<T extends gastoseventosFindManyArgs = {}>(args?: Subset<T, gastoseventosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<gastoseventos>>, PrismaPromise<Array<gastoseventosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * mes findUnique
   */
  export type mesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
    /**
     * Throw an Error if a mes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which mes to fetch.
     * 
    **/
    where: mesWhereUniqueInput
  }


  /**
   * mes findFirst
   */
  export type mesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
    /**
     * Throw an Error if a mes can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which mes to fetch.
     * 
    **/
    where?: mesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mes to fetch.
     * 
    **/
    orderBy?: Enumerable<mesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mes.
     * 
    **/
    cursor?: mesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mes.
     * 
    **/
    distinct?: Enumerable<MesScalarFieldEnum>
  }


  /**
   * mes findMany
   */
  export type mesFindManyArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
    /**
     * Filter, which mes to fetch.
     * 
    **/
    where?: mesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mes to fetch.
     * 
    **/
    orderBy?: Enumerable<mesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mes.
     * 
    **/
    cursor?: mesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MesScalarFieldEnum>
  }


  /**
   * mes create
   */
  export type mesCreateArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
    /**
     * The data needed to create a mes.
     * 
    **/
    data: XOR<mesCreateInput, mesUncheckedCreateInput>
  }


  /**
   * mes createMany
   */
  export type mesCreateManyArgs = {
    data: Enumerable<mesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mes update
   */
  export type mesUpdateArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
    /**
     * The data needed to update a mes.
     * 
    **/
    data: XOR<mesUpdateInput, mesUncheckedUpdateInput>
    /**
     * Choose, which mes to update.
     * 
    **/
    where: mesWhereUniqueInput
  }


  /**
   * mes updateMany
   */
  export type mesUpdateManyArgs = {
    data: XOR<mesUpdateManyMutationInput, mesUncheckedUpdateManyInput>
    where?: mesWhereInput
  }


  /**
   * mes upsert
   */
  export type mesUpsertArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
    /**
     * The filter to search for the mes to update in case it exists.
     * 
    **/
    where: mesWhereUniqueInput
    /**
     * In case the mes found by the `where` argument doesn't exist, create a new mes with this data.
     * 
    **/
    create: XOR<mesCreateInput, mesUncheckedCreateInput>
    /**
     * In case the mes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mesUpdateInput, mesUncheckedUpdateInput>
  }


  /**
   * mes delete
   */
  export type mesDeleteArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
    /**
     * Filter which mes to delete.
     * 
    **/
    where: mesWhereUniqueInput
  }


  /**
   * mes deleteMany
   */
  export type mesDeleteManyArgs = {
    where?: mesWhereInput
  }


  /**
   * mes without action
   */
  export type mesArgs = {
    /**
     * Select specific fields to fetch from the mes
     * 
    **/
    select?: mesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: mesInclude | null
  }



  /**
   * Model pagos
   */


  export type AggregatePagos = {
    _count: PagosCountAggregateOutputType | null
    count: PagosCountAggregateOutputType | null
    _avg: PagosAvgAggregateOutputType | null
    avg: PagosAvgAggregateOutputType | null
    _sum: PagosSumAggregateOutputType | null
    sum: PagosSumAggregateOutputType | null
    _min: PagosMinAggregateOutputType | null
    min: PagosMinAggregateOutputType | null
    _max: PagosMaxAggregateOutputType | null
    max: PagosMaxAggregateOutputType | null
  }

  export type PagosAvgAggregateOutputType = {
    id: number | null
    restante: number | null
    pagado: number | null
    total: number | null
    idevento: number | null
  }

  export type PagosSumAggregateOutputType = {
    id: number | null
    restante: number | null
    pagado: number | null
    total: number | null
    idevento: number | null
  }

  export type PagosMinAggregateOutputType = {
    id: number | null
    restante: number | null
    pagado: number | null
    total: number | null
    fechalimite: Date | null
    idevento: number | null
  }

  export type PagosMaxAggregateOutputType = {
    id: number | null
    restante: number | null
    pagado: number | null
    total: number | null
    fechalimite: Date | null
    idevento: number | null
  }

  export type PagosCountAggregateOutputType = {
    id: number
    restante: number
    pagado: number
    total: number
    fechalimite: number
    idevento: number
    _all: number
  }


  export type PagosAvgAggregateInputType = {
    id?: true
    restante?: true
    pagado?: true
    total?: true
    idevento?: true
  }

  export type PagosSumAggregateInputType = {
    id?: true
    restante?: true
    pagado?: true
    total?: true
    idevento?: true
  }

  export type PagosMinAggregateInputType = {
    id?: true
    restante?: true
    pagado?: true
    total?: true
    fechalimite?: true
    idevento?: true
  }

  export type PagosMaxAggregateInputType = {
    id?: true
    restante?: true
    pagado?: true
    total?: true
    fechalimite?: true
    idevento?: true
  }

  export type PagosCountAggregateInputType = {
    id?: true
    restante?: true
    pagado?: true
    total?: true
    fechalimite?: true
    idevento?: true
    _all?: true
  }

  export type PagosAggregateArgs = {
    /**
     * Filter which pagos to aggregate.
     * 
    **/
    where?: pagosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     * 
    **/
    orderBy?: Enumerable<pagosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pagosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pagos
    **/
    _count?: true | PagosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | PagosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: PagosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: PagosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: PagosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: PagosMaxAggregateInputType
  }

  export type GetPagosAggregateType<T extends PagosAggregateArgs> = {
        [P in keyof T & keyof AggregatePagos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagos[P]>
      : GetScalarType<T[P], AggregatePagos[P]>
  }


    
    
  export type PagosGroupByArgs = {
    where?: pagosWhereInput
    orderBy?: Enumerable<pagosOrderByInput>
    by: Array<PagosScalarFieldEnum>
    having?: pagosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagosCountAggregateInputType | true
    _avg?: PagosAvgAggregateInputType
    _sum?: PagosSumAggregateInputType
    _min?: PagosMinAggregateInputType
    _max?: PagosMaxAggregateInputType
  }


  export type PagosGroupByOutputType = {
    id: number
    restante: number | null
    pagado: number | null
    total: number | null
    fechalimite: Date | null
    idevento: number | null
    _count: PagosCountAggregateOutputType | null
    _avg: PagosAvgAggregateOutputType | null
    _sum: PagosSumAggregateOutputType | null
    _min: PagosMinAggregateOutputType | null
    _max: PagosMaxAggregateOutputType | null
  }

  type GetPagosGroupByPayload<T extends PagosGroupByArgs> = Promise<
    Array<
      PickArray<PagosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PagosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PagosGroupByOutputType[P]> 
            : GetScalarType<T[P], PagosGroupByOutputType[P]>
        }
      > 
    >


  export type pagosSelect = {
    id?: boolean
    restante?: boolean
    pagado?: boolean
    total?: boolean
    fechalimite?: boolean
    idevento?: boolean
    eventos?: boolean | eventosArgs
    abono?: boolean | abonoFindManyArgs
  }

  export type pagosInclude = {
    eventos?: boolean | eventosArgs
    abono?: boolean | abonoFindManyArgs
  }

  export type pagosGetPayload<
    S extends boolean | null | undefined | pagosArgs,
    U = keyof S
      > = S extends true
        ? pagos
    : S extends undefined
    ? never
    : S extends pagosArgs | pagosFindManyArgs
    ?'include' extends U
    ? pagos  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'eventos'
        ? eventosGetPayload<S['include'][P]> | null :
        P extends 'abono'
        ? Array < abonoGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof pagos ?pagos [P]
  : 
          P extends 'eventos'
        ? eventosGetPayload<S['select'][P]> | null :
        P extends 'abono'
        ? Array < abonoGetPayload<S['select'][P]>>  : never
  } 
    : pagos
  : pagos


  type pagosCountArgs = Merge<
    Omit<pagosFindManyArgs, 'select' | 'include'> & {
      select?: PagosCountAggregateInputType | true
    }
  >

  export interface pagosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Pagos that matches the filter.
     * @param {pagosFindUniqueArgs} args - Arguments to find a Pagos
     * @example
     * // Get one Pagos
     * const pagos = await prisma.pagos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pagosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pagosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pagos'> extends True ? CheckSelect<T, Prisma__pagosClient<pagos>, Prisma__pagosClient<pagosGetPayload<T>>> : CheckSelect<T, Prisma__pagosClient<pagos | null >, Prisma__pagosClient<pagosGetPayload<T> | null >>

    /**
     * Find the first Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosFindFirstArgs} args - Arguments to find a Pagos
     * @example
     * // Get one Pagos
     * const pagos = await prisma.pagos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pagosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pagosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pagos'> extends True ? CheckSelect<T, Prisma__pagosClient<pagos>, Prisma__pagosClient<pagosGetPayload<T>>> : CheckSelect<T, Prisma__pagosClient<pagos | null >, Prisma__pagosClient<pagosGetPayload<T> | null >>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pagos.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pagos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagosWithIdOnly = await prisma.pagos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pagosFindManyArgs>(
      args?: SelectSubset<T, pagosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<pagos>>, PrismaPromise<Array<pagosGetPayload<T>>>>

    /**
     * Create a Pagos.
     * @param {pagosCreateArgs} args - Arguments to create a Pagos.
     * @example
     * // Create one Pagos
     * const Pagos = await prisma.pagos.create({
     *   data: {
     *     // ... data to create a Pagos
     *   }
     * })
     * 
    **/
    create<T extends pagosCreateArgs>(
      args: SelectSubset<T, pagosCreateArgs>
    ): CheckSelect<T, Prisma__pagosClient<pagos>, Prisma__pagosClient<pagosGetPayload<T>>>

    /**
     * Create many Pagos.
     *     @param {pagosCreateManyArgs} args - Arguments to create many Pagos.
     *     @example
     *     // Create many Pagos
     *     const pagos = await prisma.pagos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pagosCreateManyArgs>(
      args?: SelectSubset<T, pagosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pagos.
     * @param {pagosDeleteArgs} args - Arguments to delete one Pagos.
     * @example
     * // Delete one Pagos
     * const Pagos = await prisma.pagos.delete({
     *   where: {
     *     // ... filter to delete one Pagos
     *   }
     * })
     * 
    **/
    delete<T extends pagosDeleteArgs>(
      args: SelectSubset<T, pagosDeleteArgs>
    ): CheckSelect<T, Prisma__pagosClient<pagos>, Prisma__pagosClient<pagosGetPayload<T>>>

    /**
     * Update one Pagos.
     * @param {pagosUpdateArgs} args - Arguments to update one Pagos.
     * @example
     * // Update one Pagos
     * const pagos = await prisma.pagos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pagosUpdateArgs>(
      args: SelectSubset<T, pagosUpdateArgs>
    ): CheckSelect<T, Prisma__pagosClient<pagos>, Prisma__pagosClient<pagosGetPayload<T>>>

    /**
     * Delete zero or more Pagos.
     * @param {pagosDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pagos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pagosDeleteManyArgs>(
      args?: SelectSubset<T, pagosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pagos = await prisma.pagos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pagosUpdateManyArgs>(
      args: SelectSubset<T, pagosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagos.
     * @param {pagosUpsertArgs} args - Arguments to update or create a Pagos.
     * @example
     * // Update or create a Pagos
     * const pagos = await prisma.pagos.upsert({
     *   create: {
     *     // ... data to create a Pagos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagos we want to update
     *   }
     * })
    **/
    upsert<T extends pagosUpsertArgs>(
      args: SelectSubset<T, pagosUpsertArgs>
    ): CheckSelect<T, Prisma__pagosClient<pagos>, Prisma__pagosClient<pagosGetPayload<T>>>

    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pagos.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends pagosCountArgs>(
      args?: Subset<T, pagosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagosAggregateArgs>(args: Subset<T, PagosAggregateArgs>): PrismaPromise<GetPagosAggregateType<T>>

    /**
     * Group by Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagosGroupByArgs['orderBy'] }
        : { orderBy?: PagosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for pagos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pagosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    eventos<T extends eventosArgs = {}>(args?: Subset<T, eventosArgs>): CheckSelect<T, Prisma__eventosClient<eventos | null >, Prisma__eventosClient<eventosGetPayload<T> | null >>;

    abono<T extends abonoFindManyArgs = {}>(args?: Subset<T, abonoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<abono>>, PrismaPromise<Array<abonoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * pagos findUnique
   */
  export type pagosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
    /**
     * Throw an Error if a pagos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which pagos to fetch.
     * 
    **/
    where: pagosWhereUniqueInput
  }


  /**
   * pagos findFirst
   */
  export type pagosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
    /**
     * Throw an Error if a pagos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which pagos to fetch.
     * 
    **/
    where?: pagosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     * 
    **/
    orderBy?: Enumerable<pagosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagos.
     * 
    **/
    cursor?: pagosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagos.
     * 
    **/
    distinct?: Enumerable<PagosScalarFieldEnum>
  }


  /**
   * pagos findMany
   */
  export type pagosFindManyArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
    /**
     * Filter, which pagos to fetch.
     * 
    **/
    where?: pagosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagos to fetch.
     * 
    **/
    orderBy?: Enumerable<pagosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pagos.
     * 
    **/
    cursor?: pagosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PagosScalarFieldEnum>
  }


  /**
   * pagos create
   */
  export type pagosCreateArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
    /**
     * The data needed to create a pagos.
     * 
    **/
    data: XOR<pagosCreateInput, pagosUncheckedCreateInput>
  }


  /**
   * pagos createMany
   */
  export type pagosCreateManyArgs = {
    data: Enumerable<pagosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pagos update
   */
  export type pagosUpdateArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
    /**
     * The data needed to update a pagos.
     * 
    **/
    data: XOR<pagosUpdateInput, pagosUncheckedUpdateInput>
    /**
     * Choose, which pagos to update.
     * 
    **/
    where: pagosWhereUniqueInput
  }


  /**
   * pagos updateMany
   */
  export type pagosUpdateManyArgs = {
    data: XOR<pagosUpdateManyMutationInput, pagosUncheckedUpdateManyInput>
    where?: pagosWhereInput
  }


  /**
   * pagos upsert
   */
  export type pagosUpsertArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
    /**
     * The filter to search for the pagos to update in case it exists.
     * 
    **/
    where: pagosWhereUniqueInput
    /**
     * In case the pagos found by the `where` argument doesn't exist, create a new pagos with this data.
     * 
    **/
    create: XOR<pagosCreateInput, pagosUncheckedCreateInput>
    /**
     * In case the pagos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pagosUpdateInput, pagosUncheckedUpdateInput>
  }


  /**
   * pagos delete
   */
  export type pagosDeleteArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
    /**
     * Filter which pagos to delete.
     * 
    **/
    where: pagosWhereUniqueInput
  }


  /**
   * pagos deleteMany
   */
  export type pagosDeleteManyArgs = {
    where?: pagosWhereInput
  }


  /**
   * pagos without action
   */
  export type pagosArgs = {
    /**
     * Select specific fields to fetch from the pagos
     * 
    **/
    select?: pagosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pagosInclude | null
  }



  /**
   * Model rol
   */


  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
    max: RolMaxAggregateOutputType | null
  }

  export type RolAvgAggregateOutputType = {
    id: number | null
  }

  export type RolSumAggregateOutputType = {
    id: number | null
  }

  export type RolMinAggregateOutputType = {
    id: number | null
    rol: string | null
  }

  export type RolMaxAggregateOutputType = {
    id: number | null
    rol: string | null
  }

  export type RolCountAggregateOutputType = {
    id: number
    rol: number
    _all: number
  }


  export type RolAvgAggregateInputType = {
    id?: true
  }

  export type RolSumAggregateInputType = {
    id?: true
  }

  export type RolMinAggregateInputType = {
    id?: true
    rol?: true
  }

  export type RolMaxAggregateInputType = {
    id?: true
    rol?: true
  }

  export type RolCountAggregateInputType = {
    id?: true
    rol?: true
    _all?: true
  }

  export type RolAggregateArgs = {
    /**
     * Filter which rol to aggregate.
     * 
    **/
    where?: rolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rols to fetch.
     * 
    **/
    orderBy?: Enumerable<rolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: rolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rols from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rols.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: RolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: RolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }


    
    
  export type RolGroupByArgs = {
    where?: rolWhereInput
    orderBy?: Enumerable<rolOrderByInput>
    by: Array<RolScalarFieldEnum>
    having?: rolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _avg?: RolAvgAggregateInputType
    _sum?: RolSumAggregateInputType
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }


  export type RolGroupByOutputType = {
    id: number
    rol: string | null
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Promise<
    Array<
      PickArray<RolGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RolGroupByOutputType[P]> 
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      > 
    >


  export type rolSelect = {
    id?: boolean
    rol?: boolean
    empleados?: boolean | empleadosFindManyArgs
  }

  export type rolInclude = {
    empleados?: boolean | empleadosFindManyArgs
  }

  export type rolGetPayload<
    S extends boolean | null | undefined | rolArgs,
    U = keyof S
      > = S extends true
        ? rol
    : S extends undefined
    ? never
    : S extends rolArgs | rolFindManyArgs
    ?'include' extends U
    ? rol  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'empleados'
        ? Array < empleadosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof rol ?rol [P]
  : 
          P extends 'empleados'
        ? Array < empleadosGetPayload<S['select'][P]>>  : never
  } 
    : rol
  : rol


  type rolCountArgs = Merge<
    Omit<rolFindManyArgs, 'select' | 'include'> & {
      select?: RolCountAggregateInputType | true
    }
  >

  export interface rolDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Rol that matches the filter.
     * @param {rolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rolFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'rol'> extends True ? CheckSelect<T, Prisma__rolClient<rol>, Prisma__rolClient<rolGetPayload<T>>> : CheckSelect<T, Prisma__rolClient<rol | null >, Prisma__rolClient<rolGetPayload<T> | null >>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rolFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'rol'> extends True ? CheckSelect<T, Prisma__rolClient<rol>, Prisma__rolClient<rolGetPayload<T>>> : CheckSelect<T, Prisma__rolClient<rol | null >, Prisma__rolClient<rolGetPayload<T> | null >>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolWithIdOnly = await prisma.rol.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rolFindManyArgs>(
      args?: SelectSubset<T, rolFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<rol>>, PrismaPromise<Array<rolGetPayload<T>>>>

    /**
     * Create a Rol.
     * @param {rolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
    **/
    create<T extends rolCreateArgs>(
      args: SelectSubset<T, rolCreateArgs>
    ): CheckSelect<T, Prisma__rolClient<rol>, Prisma__rolClient<rolGetPayload<T>>>

    /**
     * Create many Rols.
     *     @param {rolCreateManyArgs} args - Arguments to create many Rols.
     *     @example
     *     // Create many Rols
     *     const rol = await prisma.rol.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolCreateManyArgs>(
      args?: SelectSubset<T, rolCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Rol.
     * @param {rolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
    **/
    delete<T extends rolDeleteArgs>(
      args: SelectSubset<T, rolDeleteArgs>
    ): CheckSelect<T, Prisma__rolClient<rol>, Prisma__rolClient<rolGetPayload<T>>>

    /**
     * Update one Rol.
     * @param {rolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolUpdateArgs>(
      args: SelectSubset<T, rolUpdateArgs>
    ): CheckSelect<T, Prisma__rolClient<rol>, Prisma__rolClient<rolGetPayload<T>>>

    /**
     * Delete zero or more Rols.
     * @param {rolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolDeleteManyArgs>(
      args?: SelectSubset<T, rolDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolUpdateManyArgs>(
      args: SelectSubset<T, rolUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Rol.
     * @param {rolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
    **/
    upsert<T extends rolUpsertArgs>(
      args: SelectSubset<T, rolUpsertArgs>
    ): CheckSelect<T, Prisma__rolClient<rol>, Prisma__rolClient<rolGetPayload<T>>>

    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends rolCountArgs>(
      args?: Subset<T, rolCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rolClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleados<T extends empleadosFindManyArgs = {}>(args?: Subset<T, empleadosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<empleados>>, PrismaPromise<Array<empleadosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * rol findUnique
   */
  export type rolFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
    /**
     * Throw an Error if a rol can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which rol to fetch.
     * 
    **/
    where: rolWhereUniqueInput
  }


  /**
   * rol findFirst
   */
  export type rolFindFirstArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
    /**
     * Throw an Error if a rol can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which rol to fetch.
     * 
    **/
    where?: rolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rols to fetch.
     * 
    **/
    orderBy?: Enumerable<rolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rols.
     * 
    **/
    cursor?: rolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rols from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rols.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rols.
     * 
    **/
    distinct?: Enumerable<RolScalarFieldEnum>
  }


  /**
   * rol findMany
   */
  export type rolFindManyArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
    /**
     * Filter, which rols to fetch.
     * 
    **/
    where?: rolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rols to fetch.
     * 
    **/
    orderBy?: Enumerable<rolOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rols.
     * 
    **/
    cursor?: rolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rols from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rols.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolScalarFieldEnum>
  }


  /**
   * rol create
   */
  export type rolCreateArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
    /**
     * The data needed to create a rol.
     * 
    **/
    data: XOR<rolCreateInput, rolUncheckedCreateInput>
  }


  /**
   * rol createMany
   */
  export type rolCreateManyArgs = {
    data: Enumerable<rolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * rol update
   */
  export type rolUpdateArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
    /**
     * The data needed to update a rol.
     * 
    **/
    data: XOR<rolUpdateInput, rolUncheckedUpdateInput>
    /**
     * Choose, which rol to update.
     * 
    **/
    where: rolWhereUniqueInput
  }


  /**
   * rol updateMany
   */
  export type rolUpdateManyArgs = {
    data: XOR<rolUpdateManyMutationInput, rolUncheckedUpdateManyInput>
    where?: rolWhereInput
  }


  /**
   * rol upsert
   */
  export type rolUpsertArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
    /**
     * The filter to search for the rol to update in case it exists.
     * 
    **/
    where: rolWhereUniqueInput
    /**
     * In case the rol found by the `where` argument doesn't exist, create a new rol with this data.
     * 
    **/
    create: XOR<rolCreateInput, rolUncheckedCreateInput>
    /**
     * In case the rol was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<rolUpdateInput, rolUncheckedUpdateInput>
  }


  /**
   * rol delete
   */
  export type rolDeleteArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
    /**
     * Filter which rol to delete.
     * 
    **/
    where: rolWhereUniqueInput
  }


  /**
   * rol deleteMany
   */
  export type rolDeleteManyArgs = {
    where?: rolWhereInput
  }


  /**
   * rol without action
   */
  export type rolArgs = {
    /**
     * Select specific fields to fetch from the rol
     * 
    **/
    select?: rolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: rolInclude | null
  }



  /**
   * Model servicios
   */


  export type AggregateServicios = {
    _count: ServiciosCountAggregateOutputType | null
    count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
    max: ServiciosMaxAggregateOutputType | null
  }

  export type ServiciosAvgAggregateOutputType = {
    id: number | null
    precio: number | null
  }

  export type ServiciosSumAggregateOutputType = {
    id: number | null
    precio: number | null
  }

  export type ServiciosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    precio: number | null
    descripcion: string | null
  }

  export type ServiciosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    precio: number | null
    descripcion: string | null
  }

  export type ServiciosCountAggregateOutputType = {
    id: number
    nombre: number
    precio: number
    descripcion: number
    _all: number
  }


  export type ServiciosAvgAggregateInputType = {
    id?: true
    precio?: true
  }

  export type ServiciosSumAggregateInputType = {
    id?: true
    precio?: true
  }

  export type ServiciosMinAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    descripcion?: true
  }

  export type ServiciosMaxAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    descripcion?: true
  }

  export type ServiciosCountAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    descripcion?: true
    _all?: true
  }

  export type ServiciosAggregateArgs = {
    /**
     * Filter which servicios to aggregate.
     * 
    **/
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     * 
    **/
    orderBy?: Enumerable<serviciosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios
    **/
    _count?: true | ServiciosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ServiciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiciosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ServiciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiciosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ServiciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ServiciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ServiciosMaxAggregateInputType
  }

  export type GetServiciosAggregateType<T extends ServiciosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios[P]>
      : GetScalarType<T[P], AggregateServicios[P]>
  }


    
    
  export type ServiciosGroupByArgs = {
    where?: serviciosWhereInput
    orderBy?: Enumerable<serviciosOrderByInput>
    by: Array<ServiciosScalarFieldEnum>
    having?: serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosCountAggregateInputType | true
    _avg?: ServiciosAvgAggregateInputType
    _sum?: ServiciosSumAggregateInputType
    _min?: ServiciosMinAggregateInputType
    _max?: ServiciosMaxAggregateInputType
  }


  export type ServiciosGroupByOutputType = {
    id: number
    nombre: string | null
    precio: number | null
    descripcion: string | null
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  type GetServiciosGroupByPayload<T extends ServiciosGroupByArgs> = Promise<
    Array<
      PickArray<ServiciosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ServiciosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ServiciosGroupByOutputType[P]> 
            : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
        }
      > 
    >


  export type serviciosSelect = {
    id?: boolean
    nombre?: boolean
    precio?: boolean
    descripcion?: boolean
    servicioseventos?: boolean | servicioseventosFindManyArgs
  }

  export type serviciosInclude = {
    servicioseventos?: boolean | servicioseventosFindManyArgs
  }

  export type serviciosGetPayload<
    S extends boolean | null | undefined | serviciosArgs,
    U = keyof S
      > = S extends true
        ? servicios
    : S extends undefined
    ? never
    : S extends serviciosArgs | serviciosFindManyArgs
    ?'include' extends U
    ? servicios  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'servicioseventos'
        ? Array < servicioseventosGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof servicios ?servicios [P]
  : 
          P extends 'servicioseventos'
        ? Array < servicioseventosGetPayload<S['select'][P]>>  : never
  } 
    : servicios
  : servicios


  type serviciosCountArgs = Merge<
    Omit<serviciosFindManyArgs, 'select' | 'include'> & {
      select?: ServiciosCountAggregateInputType | true
    }
  >

  export interface serviciosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Servicios that matches the filter.
     * @param {serviciosFindUniqueArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serviciosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, serviciosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios'> extends True ? CheckSelect<T, Prisma__serviciosClient<servicios>, Prisma__serviciosClient<serviciosGetPayload<T>>> : CheckSelect<T, Prisma__serviciosClient<servicios | null >, Prisma__serviciosClient<serviciosGetPayload<T> | null >>

    /**
     * Find the first Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serviciosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, serviciosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios'> extends True ? CheckSelect<T, Prisma__serviciosClient<servicios>, Prisma__serviciosClient<serviciosGetPayload<T>>> : CheckSelect<T, Prisma__serviciosClient<servicios | null >, Prisma__serviciosClient<serviciosGetPayload<T> | null >>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicios.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviciosWithIdOnly = await prisma.servicios.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends serviciosFindManyArgs>(
      args?: SelectSubset<T, serviciosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<servicios>>, PrismaPromise<Array<serviciosGetPayload<T>>>>

    /**
     * Create a Servicios.
     * @param {serviciosCreateArgs} args - Arguments to create a Servicios.
     * @example
     * // Create one Servicios
     * const Servicios = await prisma.servicios.create({
     *   data: {
     *     // ... data to create a Servicios
     *   }
     * })
     * 
    **/
    create<T extends serviciosCreateArgs>(
      args: SelectSubset<T, serviciosCreateArgs>
    ): CheckSelect<T, Prisma__serviciosClient<servicios>, Prisma__serviciosClient<serviciosGetPayload<T>>>

    /**
     * Create many Servicios.
     *     @param {serviciosCreateManyArgs} args - Arguments to create many Servicios.
     *     @example
     *     // Create many Servicios
     *     const servicios = await prisma.servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends serviciosCreateManyArgs>(
      args?: SelectSubset<T, serviciosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios.
     * @param {serviciosDeleteArgs} args - Arguments to delete one Servicios.
     * @example
     * // Delete one Servicios
     * const Servicios = await prisma.servicios.delete({
     *   where: {
     *     // ... filter to delete one Servicios
     *   }
     * })
     * 
    **/
    delete<T extends serviciosDeleteArgs>(
      args: SelectSubset<T, serviciosDeleteArgs>
    ): CheckSelect<T, Prisma__serviciosClient<servicios>, Prisma__serviciosClient<serviciosGetPayload<T>>>

    /**
     * Update one Servicios.
     * @param {serviciosUpdateArgs} args - Arguments to update one Servicios.
     * @example
     * // Update one Servicios
     * const servicios = await prisma.servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serviciosUpdateArgs>(
      args: SelectSubset<T, serviciosUpdateArgs>
    ): CheckSelect<T, Prisma__serviciosClient<servicios>, Prisma__serviciosClient<serviciosGetPayload<T>>>

    /**
     * Delete zero or more Servicios.
     * @param {serviciosDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serviciosDeleteManyArgs>(
      args?: SelectSubset<T, serviciosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicios = await prisma.servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serviciosUpdateManyArgs>(
      args: SelectSubset<T, serviciosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios.
     * @param {serviciosUpsertArgs} args - Arguments to update or create a Servicios.
     * @example
     * // Update or create a Servicios
     * const servicios = await prisma.servicios.upsert({
     *   create: {
     *     // ... data to create a Servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios we want to update
     *   }
     * })
    **/
    upsert<T extends serviciosUpsertArgs>(
      args: SelectSubset<T, serviciosUpsertArgs>
    ): CheckSelect<T, Prisma__serviciosClient<servicios>, Prisma__serviciosClient<serviciosGetPayload<T>>>

    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicios.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends serviciosCountArgs>(
      args?: Subset<T, serviciosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosAggregateArgs>(args: Subset<T, ServiciosAggregateArgs>): PrismaPromise<GetServiciosAggregateType<T>>

    /**
     * Group by Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiciosGroupByArgs['orderBy'] }
        : { orderBy?: ServiciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__serviciosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    servicioseventos<T extends servicioseventosFindManyArgs = {}>(args?: Subset<T, servicioseventosFindManyArgs>): CheckSelect<T, PrismaPromise<Array<servicioseventos>>, PrismaPromise<Array<servicioseventosGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * servicios findUnique
   */
  export type serviciosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
    /**
     * Throw an Error if a servicios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which servicios to fetch.
     * 
    **/
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios findFirst
   */
  export type serviciosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
    /**
     * Throw an Error if a servicios can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which servicios to fetch.
     * 
    **/
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     * 
    **/
    orderBy?: Enumerable<serviciosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     * 
    **/
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     * 
    **/
    distinct?: Enumerable<ServiciosScalarFieldEnum>
  }


  /**
   * servicios findMany
   */
  export type serviciosFindManyArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
    /**
     * Filter, which servicios to fetch.
     * 
    **/
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     * 
    **/
    orderBy?: Enumerable<serviciosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios.
     * 
    **/
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServiciosScalarFieldEnum>
  }


  /**
   * servicios create
   */
  export type serviciosCreateArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
    /**
     * The data needed to create a servicios.
     * 
    **/
    data: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
  }


  /**
   * servicios createMany
   */
  export type serviciosCreateManyArgs = {
    data: Enumerable<serviciosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicios update
   */
  export type serviciosUpdateArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
    /**
     * The data needed to update a servicios.
     * 
    **/
    data: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
    /**
     * Choose, which servicios to update.
     * 
    **/
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios updateMany
   */
  export type serviciosUpdateManyArgs = {
    data: XOR<serviciosUpdateManyMutationInput, serviciosUncheckedUpdateManyInput>
    where?: serviciosWhereInput
  }


  /**
   * servicios upsert
   */
  export type serviciosUpsertArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
    /**
     * The filter to search for the servicios to update in case it exists.
     * 
    **/
    where: serviciosWhereUniqueInput
    /**
     * In case the servicios found by the `where` argument doesn't exist, create a new servicios with this data.
     * 
    **/
    create: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
    /**
     * In case the servicios was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
  }


  /**
   * servicios delete
   */
  export type serviciosDeleteArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
    /**
     * Filter which servicios to delete.
     * 
    **/
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios deleteMany
   */
  export type serviciosDeleteManyArgs = {
    where?: serviciosWhereInput
  }


  /**
   * servicios without action
   */
  export type serviciosArgs = {
    /**
     * Select specific fields to fetch from the servicios
     * 
    **/
    select?: serviciosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: serviciosInclude | null
  }



  /**
   * Model servicioseventos
   */


  export type AggregateServicioseventos = {
    _count: ServicioseventosCountAggregateOutputType | null
    count: ServicioseventosCountAggregateOutputType | null
    _avg: ServicioseventosAvgAggregateOutputType | null
    avg: ServicioseventosAvgAggregateOutputType | null
    _sum: ServicioseventosSumAggregateOutputType | null
    sum: ServicioseventosSumAggregateOutputType | null
    _min: ServicioseventosMinAggregateOutputType | null
    min: ServicioseventosMinAggregateOutputType | null
    _max: ServicioseventosMaxAggregateOutputType | null
    max: ServicioseventosMaxAggregateOutputType | null
  }

  export type ServicioseventosAvgAggregateOutputType = {
    id: number | null
    idevento: number | null
    idservicio: number | null
    idempleado: number | null
    precio: number | null
  }

  export type ServicioseventosSumAggregateOutputType = {
    id: number | null
    idevento: number | null
    idservicio: number | null
    idempleado: number | null
    precio: number | null
  }

  export type ServicioseventosMinAggregateOutputType = {
    id: number | null
    idevento: number | null
    idservicio: number | null
    idempleado: number | null
    precio: number | null
  }

  export type ServicioseventosMaxAggregateOutputType = {
    id: number | null
    idevento: number | null
    idservicio: number | null
    idempleado: number | null
    precio: number | null
  }

  export type ServicioseventosCountAggregateOutputType = {
    id: number
    idevento: number
    idservicio: number
    idempleado: number
    precio: number
    _all: number
  }


  export type ServicioseventosAvgAggregateInputType = {
    id?: true
    idevento?: true
    idservicio?: true
    idempleado?: true
    precio?: true
  }

  export type ServicioseventosSumAggregateInputType = {
    id?: true
    idevento?: true
    idservicio?: true
    idempleado?: true
    precio?: true
  }

  export type ServicioseventosMinAggregateInputType = {
    id?: true
    idevento?: true
    idservicio?: true
    idempleado?: true
    precio?: true
  }

  export type ServicioseventosMaxAggregateInputType = {
    id?: true
    idevento?: true
    idservicio?: true
    idempleado?: true
    precio?: true
  }

  export type ServicioseventosCountAggregateInputType = {
    id?: true
    idevento?: true
    idservicio?: true
    idempleado?: true
    precio?: true
    _all?: true
  }

  export type ServicioseventosAggregateArgs = {
    /**
     * Filter which servicioseventos to aggregate.
     * 
    **/
    where?: servicioseventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicioseventos to fetch.
     * 
    **/
    orderBy?: Enumerable<servicioseventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: servicioseventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicioseventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicioseventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicioseventos
    **/
    _count?: true | ServicioseventosCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ServicioseventosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioseventosAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ServicioseventosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioseventosSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ServicioseventosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioseventosMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ServicioseventosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioseventosMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ServicioseventosMaxAggregateInputType
  }

  export type GetServicioseventosAggregateType<T extends ServicioseventosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicioseventos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicioseventos[P]>
      : GetScalarType<T[P], AggregateServicioseventos[P]>
  }


    
    
  export type ServicioseventosGroupByArgs = {
    where?: servicioseventosWhereInput
    orderBy?: Enumerable<servicioseventosOrderByInput>
    by: Array<ServicioseventosScalarFieldEnum>
    having?: servicioseventosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioseventosCountAggregateInputType | true
    _avg?: ServicioseventosAvgAggregateInputType
    _sum?: ServicioseventosSumAggregateInputType
    _min?: ServicioseventosMinAggregateInputType
    _max?: ServicioseventosMaxAggregateInputType
  }


  export type ServicioseventosGroupByOutputType = {
    id: number
    idevento: number | null
    idservicio: number | null
    idempleado: number | null
    precio: number | null
    _count: ServicioseventosCountAggregateOutputType | null
    _avg: ServicioseventosAvgAggregateOutputType | null
    _sum: ServicioseventosSumAggregateOutputType | null
    _min: ServicioseventosMinAggregateOutputType | null
    _max: ServicioseventosMaxAggregateOutputType | null
  }

  type GetServicioseventosGroupByPayload<T extends ServicioseventosGroupByArgs> = Promise<
    Array<
      PickArray<ServicioseventosGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ServicioseventosGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ServicioseventosGroupByOutputType[P]> 
            : GetScalarType<T[P], ServicioseventosGroupByOutputType[P]>
        }
      > 
    >


  export type servicioseventosSelect = {
    id?: boolean
    idevento?: boolean
    idservicio?: boolean
    idempleado?: boolean
    precio?: boolean
    empleados?: boolean | empleadosArgs
    eventos?: boolean | eventosArgs
    servicios?: boolean | serviciosArgs
  }

  export type servicioseventosInclude = {
    empleados?: boolean | empleadosArgs
    eventos?: boolean | eventosArgs
    servicios?: boolean | serviciosArgs
  }

  export type servicioseventosGetPayload<
    S extends boolean | null | undefined | servicioseventosArgs,
    U = keyof S
      > = S extends true
        ? servicioseventos
    : S extends undefined
    ? never
    : S extends servicioseventosArgs | servicioseventosFindManyArgs
    ?'include' extends U
    ? servicioseventos  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'empleados'
        ? empleadosGetPayload<S['include'][P]> | null :
        P extends 'eventos'
        ? eventosGetPayload<S['include'][P]> | null :
        P extends 'servicios'
        ? serviciosGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof servicioseventos ?servicioseventos [P]
  : 
          P extends 'empleados'
        ? empleadosGetPayload<S['select'][P]> | null :
        P extends 'eventos'
        ? eventosGetPayload<S['select'][P]> | null :
        P extends 'servicios'
        ? serviciosGetPayload<S['select'][P]> | null : never
  } 
    : servicioseventos
  : servicioseventos


  type servicioseventosCountArgs = Merge<
    Omit<servicioseventosFindManyArgs, 'select' | 'include'> & {
      select?: ServicioseventosCountAggregateInputType | true
    }
  >

  export interface servicioseventosDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Servicioseventos that matches the filter.
     * @param {servicioseventosFindUniqueArgs} args - Arguments to find a Servicioseventos
     * @example
     * // Get one Servicioseventos
     * const servicioseventos = await prisma.servicioseventos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicioseventosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicioseventosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicioseventos'> extends True ? CheckSelect<T, Prisma__servicioseventosClient<servicioseventos>, Prisma__servicioseventosClient<servicioseventosGetPayload<T>>> : CheckSelect<T, Prisma__servicioseventosClient<servicioseventos | null >, Prisma__servicioseventosClient<servicioseventosGetPayload<T> | null >>

    /**
     * Find the first Servicioseventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioseventosFindFirstArgs} args - Arguments to find a Servicioseventos
     * @example
     * // Get one Servicioseventos
     * const servicioseventos = await prisma.servicioseventos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicioseventosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicioseventosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicioseventos'> extends True ? CheckSelect<T, Prisma__servicioseventosClient<servicioseventos>, Prisma__servicioseventosClient<servicioseventosGetPayload<T>>> : CheckSelect<T, Prisma__servicioseventosClient<servicioseventos | null >, Prisma__servicioseventosClient<servicioseventosGetPayload<T> | null >>

    /**
     * Find zero or more Servicioseventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioseventosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicioseventos
     * const servicioseventos = await prisma.servicioseventos.findMany()
     * 
     * // Get first 10 Servicioseventos
     * const servicioseventos = await prisma.servicioseventos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicioseventosWithIdOnly = await prisma.servicioseventos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends servicioseventosFindManyArgs>(
      args?: SelectSubset<T, servicioseventosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<servicioseventos>>, PrismaPromise<Array<servicioseventosGetPayload<T>>>>

    /**
     * Create a Servicioseventos.
     * @param {servicioseventosCreateArgs} args - Arguments to create a Servicioseventos.
     * @example
     * // Create one Servicioseventos
     * const Servicioseventos = await prisma.servicioseventos.create({
     *   data: {
     *     // ... data to create a Servicioseventos
     *   }
     * })
     * 
    **/
    create<T extends servicioseventosCreateArgs>(
      args: SelectSubset<T, servicioseventosCreateArgs>
    ): CheckSelect<T, Prisma__servicioseventosClient<servicioseventos>, Prisma__servicioseventosClient<servicioseventosGetPayload<T>>>

    /**
     * Create many Servicioseventos.
     *     @param {servicioseventosCreateManyArgs} args - Arguments to create many Servicioseventos.
     *     @example
     *     // Create many Servicioseventos
     *     const servicioseventos = await prisma.servicioseventos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicioseventosCreateManyArgs>(
      args?: SelectSubset<T, servicioseventosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Servicioseventos.
     * @param {servicioseventosDeleteArgs} args - Arguments to delete one Servicioseventos.
     * @example
     * // Delete one Servicioseventos
     * const Servicioseventos = await prisma.servicioseventos.delete({
     *   where: {
     *     // ... filter to delete one Servicioseventos
     *   }
     * })
     * 
    **/
    delete<T extends servicioseventosDeleteArgs>(
      args: SelectSubset<T, servicioseventosDeleteArgs>
    ): CheckSelect<T, Prisma__servicioseventosClient<servicioseventos>, Prisma__servicioseventosClient<servicioseventosGetPayload<T>>>

    /**
     * Update one Servicioseventos.
     * @param {servicioseventosUpdateArgs} args - Arguments to update one Servicioseventos.
     * @example
     * // Update one Servicioseventos
     * const servicioseventos = await prisma.servicioseventos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicioseventosUpdateArgs>(
      args: SelectSubset<T, servicioseventosUpdateArgs>
    ): CheckSelect<T, Prisma__servicioseventosClient<servicioseventos>, Prisma__servicioseventosClient<servicioseventosGetPayload<T>>>

    /**
     * Delete zero or more Servicioseventos.
     * @param {servicioseventosDeleteManyArgs} args - Arguments to filter Servicioseventos to delete.
     * @example
     * // Delete a few Servicioseventos
     * const { count } = await prisma.servicioseventos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicioseventosDeleteManyArgs>(
      args?: SelectSubset<T, servicioseventosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicioseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioseventosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicioseventos
     * const servicioseventos = await prisma.servicioseventos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicioseventosUpdateManyArgs>(
      args: SelectSubset<T, servicioseventosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicioseventos.
     * @param {servicioseventosUpsertArgs} args - Arguments to update or create a Servicioseventos.
     * @example
     * // Update or create a Servicioseventos
     * const servicioseventos = await prisma.servicioseventos.upsert({
     *   create: {
     *     // ... data to create a Servicioseventos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicioseventos we want to update
     *   }
     * })
    **/
    upsert<T extends servicioseventosUpsertArgs>(
      args: SelectSubset<T, servicioseventosUpsertArgs>
    ): CheckSelect<T, Prisma__servicioseventosClient<servicioseventos>, Prisma__servicioseventosClient<servicioseventosGetPayload<T>>>

    /**
     * Count the number of Servicioseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioseventosCountArgs} args - Arguments to filter Servicioseventos to count.
     * @example
     * // Count the number of Servicioseventos
     * const count = await prisma.servicioseventos.count({
     *   where: {
     *     // ... the filter for the Servicioseventos we want to count
     *   }
     * })
    **/
    count<T extends servicioseventosCountArgs>(
      args?: Subset<T, servicioseventosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioseventosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicioseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioseventosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioseventosAggregateArgs>(args: Subset<T, ServicioseventosAggregateArgs>): PrismaPromise<GetServicioseventosAggregateType<T>>

    /**
     * Group by Servicioseventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioseventosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioseventosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioseventosGroupByArgs['orderBy'] }
        : { orderBy?: ServicioseventosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioseventosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioseventosGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicioseventos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicioseventosClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    empleados<T extends empleadosArgs = {}>(args?: Subset<T, empleadosArgs>): CheckSelect<T, Prisma__empleadosClient<empleados | null >, Prisma__empleadosClient<empleadosGetPayload<T> | null >>;

    eventos<T extends eventosArgs = {}>(args?: Subset<T, eventosArgs>): CheckSelect<T, Prisma__eventosClient<eventos | null >, Prisma__eventosClient<eventosGetPayload<T> | null >>;

    servicios<T extends serviciosArgs = {}>(args?: Subset<T, serviciosArgs>): CheckSelect<T, Prisma__serviciosClient<servicios | null >, Prisma__serviciosClient<serviciosGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * servicioseventos findUnique
   */
  export type servicioseventosFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
    /**
     * Throw an Error if a servicioseventos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which servicioseventos to fetch.
     * 
    **/
    where: servicioseventosWhereUniqueInput
  }


  /**
   * servicioseventos findFirst
   */
  export type servicioseventosFindFirstArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
    /**
     * Throw an Error if a servicioseventos can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which servicioseventos to fetch.
     * 
    **/
    where?: servicioseventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicioseventos to fetch.
     * 
    **/
    orderBy?: Enumerable<servicioseventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicioseventos.
     * 
    **/
    cursor?: servicioseventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicioseventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicioseventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicioseventos.
     * 
    **/
    distinct?: Enumerable<ServicioseventosScalarFieldEnum>
  }


  /**
   * servicioseventos findMany
   */
  export type servicioseventosFindManyArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
    /**
     * Filter, which servicioseventos to fetch.
     * 
    **/
    where?: servicioseventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicioseventos to fetch.
     * 
    **/
    orderBy?: Enumerable<servicioseventosOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicioseventos.
     * 
    **/
    cursor?: servicioseventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicioseventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicioseventos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServicioseventosScalarFieldEnum>
  }


  /**
   * servicioseventos create
   */
  export type servicioseventosCreateArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
    /**
     * The data needed to create a servicioseventos.
     * 
    **/
    data: XOR<servicioseventosCreateInput, servicioseventosUncheckedCreateInput>
  }


  /**
   * servicioseventos createMany
   */
  export type servicioseventosCreateManyArgs = {
    data: Enumerable<servicioseventosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicioseventos update
   */
  export type servicioseventosUpdateArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
    /**
     * The data needed to update a servicioseventos.
     * 
    **/
    data: XOR<servicioseventosUpdateInput, servicioseventosUncheckedUpdateInput>
    /**
     * Choose, which servicioseventos to update.
     * 
    **/
    where: servicioseventosWhereUniqueInput
  }


  /**
   * servicioseventos updateMany
   */
  export type servicioseventosUpdateManyArgs = {
    data: XOR<servicioseventosUpdateManyMutationInput, servicioseventosUncheckedUpdateManyInput>
    where?: servicioseventosWhereInput
  }


  /**
   * servicioseventos upsert
   */
  export type servicioseventosUpsertArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
    /**
     * The filter to search for the servicioseventos to update in case it exists.
     * 
    **/
    where: servicioseventosWhereUniqueInput
    /**
     * In case the servicioseventos found by the `where` argument doesn't exist, create a new servicioseventos with this data.
     * 
    **/
    create: XOR<servicioseventosCreateInput, servicioseventosUncheckedCreateInput>
    /**
     * In case the servicioseventos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<servicioseventosUpdateInput, servicioseventosUncheckedUpdateInput>
  }


  /**
   * servicioseventos delete
   */
  export type servicioseventosDeleteArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
    /**
     * Filter which servicioseventos to delete.
     * 
    **/
    where: servicioseventosWhereUniqueInput
  }


  /**
   * servicioseventos deleteMany
   */
  export type servicioseventosDeleteManyArgs = {
    where?: servicioseventosWhereInput
  }


  /**
   * servicioseventos without action
   */
  export type servicioseventosArgs = {
    /**
     * Select specific fields to fetch from the servicioseventos
     * 
    **/
    select?: servicioseventosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicioseventosInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ClienteScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    telefono: 'telefono',
    direccion: 'direccion'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const EventosScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    hora: 'hora',
    total: 'total',
    idpaquete: 'idpaquete',
    idcliente: 'idcliente',
    celebracion: 'celebracion',
    pagado: 'pagado'
  };

  export type EventosScalarFieldEnum = (typeof EventosScalarFieldEnum)[keyof typeof EventosScalarFieldEnum]


  export const PaqueteScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    adultos: 'adultos',
    ninios: 'ninios',
    precio: 'precio',
    preciounitario: 'preciounitario'
  };

  export type PaqueteScalarFieldEnum = (typeof PaqueteScalarFieldEnum)[keyof typeof PaqueteScalarFieldEnum]


  export const PaqueteeventoScalarFieldEnum: {
    id: 'id',
    adultos: 'adultos',
    ninios: 'ninios',
    total: 'total',
    idpaquete: 'idpaquete'
  };

  export type PaqueteeventoScalarFieldEnum = (typeof PaqueteeventoScalarFieldEnum)[keyof typeof PaqueteeventoScalarFieldEnum]


  export const AbonoScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    cantidad: 'cantidad',
    idcliente: 'idcliente',
    idpagos: 'idpagos'
  };

  export type AbonoScalarFieldEnum = (typeof AbonoScalarFieldEnum)[keyof typeof AbonoScalarFieldEnum]


  export const EmpleadosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    direccion: 'direccion',
    telefono: 'telefono',
    descripcion: 'descripcion',
    idrol: 'idrol'
  };

  export type EmpleadosScalarFieldEnum = (typeof EmpleadosScalarFieldEnum)[keyof typeof EmpleadosScalarFieldEnum]


  export const GastofijoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    total: 'total',
    activo: 'activo',
    idmes: 'idmes'
  };

  export type GastofijoScalarFieldEnum = (typeof GastofijoScalarFieldEnum)[keyof typeof GastofijoScalarFieldEnum]


  export const GastoseventosScalarFieldEnum: {
    id: 'id',
    monto: 'monto',
    motivo: 'motivo',
    descripcion: 'descripcion',
    idmes: 'idmes',
    idevento: 'idevento'
  };

  export type GastoseventosScalarFieldEnum = (typeof GastoseventosScalarFieldEnum)[keyof typeof GastoseventosScalarFieldEnum]


  export const MesScalarFieldEnum: {
    id: 'id',
    mes: 'mes',
    gastos: 'gastos',
    ganancias: 'ganancias'
  };

  export type MesScalarFieldEnum = (typeof MesScalarFieldEnum)[keyof typeof MesScalarFieldEnum]


  export const PagosScalarFieldEnum: {
    id: 'id',
    restante: 'restante',
    pagado: 'pagado',
    total: 'total',
    fechalimite: 'fechalimite',
    idevento: 'idevento'
  };

  export type PagosScalarFieldEnum = (typeof PagosScalarFieldEnum)[keyof typeof PagosScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id: 'id',
    rol: 'rol'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const ServiciosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    precio: 'precio',
    descripcion: 'descripcion'
  };

  export type ServiciosScalarFieldEnum = (typeof ServiciosScalarFieldEnum)[keyof typeof ServiciosScalarFieldEnum]


  export const ServicioseventosScalarFieldEnum: {
    id: 'id',
    idevento: 'idevento',
    idservicio: 'idservicio',
    idempleado: 'idempleado',
    precio: 'precio'
  };

  export type ServicioseventosScalarFieldEnum = (typeof ServicioseventosScalarFieldEnum)[keyof typeof ServicioseventosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type clienteWhereInput = {
    AND?: Enumerable<clienteWhereInput>
    OR?: Enumerable<clienteWhereInput>
    NOT?: Enumerable<clienteWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    telefono?: IntNullableFilter | number | null
    direccion?: StringNullableFilter | string | null
    abono?: AbonoListRelationFilter
    eventos?: EventosListRelationFilter
  }

  export type clienteOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
  }

  export type clienteWhereUniqueInput = {
    id?: number
  }

  export type clienteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<clienteScalarWhereWithAggregatesInput>
    OR?: Enumerable<clienteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<clienteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    telefono?: IntNullableWithAggregatesFilter | number | null
    direccion?: StringNullableWithAggregatesFilter | string | null
  }

  export type eventosWhereInput = {
    AND?: Enumerable<eventosWhereInput>
    OR?: Enumerable<eventosWhereInput>
    NOT?: Enumerable<eventosWhereInput>
    id?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    hora?: DateTimeNullableFilter | Date | string | null
    total?: IntNullableFilter | number | null
    idpaquete?: IntNullableFilter | number | null
    idcliente?: IntNullableFilter | number | null
    celebracion?: StringNullableFilter | string | null
    pagado?: BoolNullableFilter | boolean | null
    cliente?: XOR<ClienteRelationFilter, clienteWhereInput> | null
    paqueteevento?: XOR<PaqueteeventoRelationFilter, paqueteeventoWhereInput> | null
    gastoseventos?: GastoseventosListRelationFilter
    pagos?: PagosListRelationFilter
    servicioseventos?: ServicioseventosListRelationFilter
  }

  export type eventosOrderByInput = {
    id?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    total?: SortOrder
    idpaquete?: SortOrder
    idcliente?: SortOrder
    celebracion?: SortOrder
    pagado?: SortOrder
  }

  export type eventosWhereUniqueInput = {
    id?: number
  }

  export type eventosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<eventosScalarWhereWithAggregatesInput>
    OR?: Enumerable<eventosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<eventosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hora?: DateTimeNullableWithAggregatesFilter | Date | string | null
    total?: IntNullableWithAggregatesFilter | number | null
    idpaquete?: IntNullableWithAggregatesFilter | number | null
    idcliente?: IntNullableWithAggregatesFilter | number | null
    celebracion?: StringNullableWithAggregatesFilter | string | null
    pagado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type paqueteWhereInput = {
    AND?: Enumerable<paqueteWhereInput>
    OR?: Enumerable<paqueteWhereInput>
    NOT?: Enumerable<paqueteWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    adultos?: IntNullableFilter | number | null
    ninios?: IntNullableFilter | number | null
    precio?: IntNullableFilter | number | null
    preciounitario?: IntNullableFilter | number | null
    paqueteevento?: PaqueteeventoListRelationFilter
  }

  export type paqueteOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    adultos?: SortOrder
    ninios?: SortOrder
    precio?: SortOrder
    preciounitario?: SortOrder
  }

  export type paqueteWhereUniqueInput = {
    id?: number
  }

  export type paqueteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paqueteScalarWhereWithAggregatesInput>
    OR?: Enumerable<paqueteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paqueteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    adultos?: IntNullableWithAggregatesFilter | number | null
    ninios?: IntNullableWithAggregatesFilter | number | null
    precio?: IntNullableWithAggregatesFilter | number | null
    preciounitario?: IntNullableWithAggregatesFilter | number | null
  }

  export type paqueteeventoWhereInput = {
    AND?: Enumerable<paqueteeventoWhereInput>
    OR?: Enumerable<paqueteeventoWhereInput>
    NOT?: Enumerable<paqueteeventoWhereInput>
    id?: IntFilter | number
    adultos?: IntNullableFilter | number | null
    ninios?: IntNullableFilter | number | null
    total?: IntNullableFilter | number | null
    idpaquete?: IntNullableFilter | number | null
    paquete?: XOR<PaqueteRelationFilter, paqueteWhereInput> | null
    eventos?: EventosListRelationFilter
  }

  export type paqueteeventoOrderByInput = {
    id?: SortOrder
    adultos?: SortOrder
    ninios?: SortOrder
    total?: SortOrder
    idpaquete?: SortOrder
  }

  export type paqueteeventoWhereUniqueInput = {
    id?: number
  }

  export type paqueteeventoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paqueteeventoScalarWhereWithAggregatesInput>
    OR?: Enumerable<paqueteeventoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paqueteeventoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    adultos?: IntNullableWithAggregatesFilter | number | null
    ninios?: IntNullableWithAggregatesFilter | number | null
    total?: IntNullableWithAggregatesFilter | number | null
    idpaquete?: IntNullableWithAggregatesFilter | number | null
  }

  export type abonoWhereInput = {
    AND?: Enumerable<abonoWhereInput>
    OR?: Enumerable<abonoWhereInput>
    NOT?: Enumerable<abonoWhereInput>
    id?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    cantidad?: IntNullableFilter | number | null
    idcliente?: IntNullableFilter | number | null
    idpagos?: IntNullableFilter | number | null
    cliente?: XOR<ClienteRelationFilter, clienteWhereInput> | null
    pagos?: XOR<PagosRelationFilter, pagosWhereInput> | null
  }

  export type abonoOrderByInput = {
    id?: SortOrder
    fecha?: SortOrder
    cantidad?: SortOrder
    idcliente?: SortOrder
    idpagos?: SortOrder
  }

  export type abonoWhereUniqueInput = {
    id?: number
  }

  export type abonoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<abonoScalarWhereWithAggregatesInput>
    OR?: Enumerable<abonoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<abonoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cantidad?: IntNullableWithAggregatesFilter | number | null
    idcliente?: IntNullableWithAggregatesFilter | number | null
    idpagos?: IntNullableWithAggregatesFilter | number | null
  }

  export type empleadosWhereInput = {
    AND?: Enumerable<empleadosWhereInput>
    OR?: Enumerable<empleadosWhereInput>
    NOT?: Enumerable<empleadosWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    direccion?: StringNullableFilter | string | null
    telefono?: IntNullableFilter | number | null
    descripcion?: StringNullableFilter | string | null
    idrol?: IntNullableFilter | number | null
    rol?: XOR<RolRelationFilter, rolWhereInput> | null
    servicioseventos?: ServicioseventosListRelationFilter
  }

  export type empleadosOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    descripcion?: SortOrder
    idrol?: SortOrder
  }

  export type empleadosWhereUniqueInput = {
    id?: number
  }

  export type empleadosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<empleadosScalarWhereWithAggregatesInput>
    OR?: Enumerable<empleadosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<empleadosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    direccion?: StringNullableWithAggregatesFilter | string | null
    telefono?: IntNullableWithAggregatesFilter | number | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
    idrol?: IntNullableWithAggregatesFilter | number | null
  }

  export type gastofijoWhereInput = {
    AND?: Enumerable<gastofijoWhereInput>
    OR?: Enumerable<gastofijoWhereInput>
    NOT?: Enumerable<gastofijoWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    descripcion?: StringNullableFilter | string | null
    total?: IntNullableFilter | number | null
    activo?: BoolNullableFilter | boolean | null
    idmes?: IntNullableFilter | number | null
  }

  export type gastofijoOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    total?: SortOrder
    activo?: SortOrder
    idmes?: SortOrder
  }

  export type gastofijoWhereUniqueInput = {
    id?: number
  }

  export type gastofijoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<gastofijoScalarWhereWithAggregatesInput>
    OR?: Enumerable<gastofijoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<gastofijoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
    total?: IntNullableWithAggregatesFilter | number | null
    activo?: BoolNullableWithAggregatesFilter | boolean | null
    idmes?: IntNullableWithAggregatesFilter | number | null
  }

  export type gastoseventosWhereInput = {
    AND?: Enumerable<gastoseventosWhereInput>
    OR?: Enumerable<gastoseventosWhereInput>
    NOT?: Enumerable<gastoseventosWhereInput>
    id?: IntFilter | number
    monto?: IntNullableFilter | number | null
    motivo?: StringNullableFilter | string | null
    descripcion?: StringNullableFilter | string | null
    idmes?: IntNullableFilter | number | null
    idevento?: IntNullableFilter | number | null
    eventos?: XOR<EventosRelationFilter, eventosWhereInput> | null
    mes?: XOR<MesRelationFilter, mesWhereInput> | null
  }

  export type gastoseventosOrderByInput = {
    id?: SortOrder
    monto?: SortOrder
    motivo?: SortOrder
    descripcion?: SortOrder
    idmes?: SortOrder
    idevento?: SortOrder
  }

  export type gastoseventosWhereUniqueInput = {
    id?: number
  }

  export type gastoseventosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<gastoseventosScalarWhereWithAggregatesInput>
    OR?: Enumerable<gastoseventosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<gastoseventosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    monto?: IntNullableWithAggregatesFilter | number | null
    motivo?: StringNullableWithAggregatesFilter | string | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
    idmes?: IntNullableWithAggregatesFilter | number | null
    idevento?: IntNullableWithAggregatesFilter | number | null
  }

  export type mesWhereInput = {
    AND?: Enumerable<mesWhereInput>
    OR?: Enumerable<mesWhereInput>
    NOT?: Enumerable<mesWhereInput>
    id?: IntFilter | number
    mes?: DateTimeNullableFilter | Date | string | null
    gastos?: IntNullableFilter | number | null
    ganancias?: IntNullableFilter | number | null
    gastoseventos?: GastoseventosListRelationFilter
  }

  export type mesOrderByInput = {
    id?: SortOrder
    mes?: SortOrder
    gastos?: SortOrder
    ganancias?: SortOrder
  }

  export type mesWhereUniqueInput = {
    id?: number
  }

  export type mesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mesScalarWhereWithAggregatesInput>
    OR?: Enumerable<mesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    mes?: DateTimeNullableWithAggregatesFilter | Date | string | null
    gastos?: IntNullableWithAggregatesFilter | number | null
    ganancias?: IntNullableWithAggregatesFilter | number | null
  }

  export type pagosWhereInput = {
    AND?: Enumerable<pagosWhereInput>
    OR?: Enumerable<pagosWhereInput>
    NOT?: Enumerable<pagosWhereInput>
    id?: IntFilter | number
    restante?: IntNullableFilter | number | null
    pagado?: IntNullableFilter | number | null
    total?: IntNullableFilter | number | null
    fechalimite?: DateTimeNullableFilter | Date | string | null
    idevento?: IntNullableFilter | number | null
    eventos?: XOR<EventosRelationFilter, eventosWhereInput> | null
    abono?: AbonoListRelationFilter
  }

  export type pagosOrderByInput = {
    id?: SortOrder
    restante?: SortOrder
    pagado?: SortOrder
    total?: SortOrder
    fechalimite?: SortOrder
    idevento?: SortOrder
  }

  export type pagosWhereUniqueInput = {
    id?: number
  }

  export type pagosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pagosScalarWhereWithAggregatesInput>
    OR?: Enumerable<pagosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pagosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    restante?: IntNullableWithAggregatesFilter | number | null
    pagado?: IntNullableWithAggregatesFilter | number | null
    total?: IntNullableWithAggregatesFilter | number | null
    fechalimite?: DateTimeNullableWithAggregatesFilter | Date | string | null
    idevento?: IntNullableWithAggregatesFilter | number | null
  }

  export type rolWhereInput = {
    AND?: Enumerable<rolWhereInput>
    OR?: Enumerable<rolWhereInput>
    NOT?: Enumerable<rolWhereInput>
    id?: IntFilter | number
    rol?: StringNullableFilter | string | null
    empleados?: EmpleadosListRelationFilter
  }

  export type rolOrderByInput = {
    id?: SortOrder
    rol?: SortOrder
  }

  export type rolWhereUniqueInput = {
    id?: number
  }

  export type rolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<rolScalarWhereWithAggregatesInput>
    OR?: Enumerable<rolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<rolScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    rol?: StringNullableWithAggregatesFilter | string | null
  }

  export type serviciosWhereInput = {
    AND?: Enumerable<serviciosWhereInput>
    OR?: Enumerable<serviciosWhereInput>
    NOT?: Enumerable<serviciosWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    precio?: IntNullableFilter | number | null
    descripcion?: StringNullableFilter | string | null
    servicioseventos?: ServicioseventosListRelationFilter
  }

  export type serviciosOrderByInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    descripcion?: SortOrder
  }

  export type serviciosWhereUniqueInput = {
    id?: number
  }

  export type serviciosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<serviciosScalarWhereWithAggregatesInput>
    OR?: Enumerable<serviciosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<serviciosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    precio?: IntNullableWithAggregatesFilter | number | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicioseventosWhereInput = {
    AND?: Enumerable<servicioseventosWhereInput>
    OR?: Enumerable<servicioseventosWhereInput>
    NOT?: Enumerable<servicioseventosWhereInput>
    id?: IntFilter | number
    idevento?: IntNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
    idempleado?: IntNullableFilter | number | null
    precio?: IntNullableFilter | number | null
    empleados?: XOR<EmpleadosRelationFilter, empleadosWhereInput> | null
    eventos?: XOR<EventosRelationFilter, eventosWhereInput> | null
    servicios?: XOR<ServiciosRelationFilter, serviciosWhereInput> | null
  }

  export type servicioseventosOrderByInput = {
    id?: SortOrder
    idevento?: SortOrder
    idservicio?: SortOrder
    idempleado?: SortOrder
    precio?: SortOrder
  }

  export type servicioseventosWhereUniqueInput = {
    id?: number
  }

  export type servicioseventosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicioseventosScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicioseventosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicioseventosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idevento?: IntNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    idempleado?: IntNullableWithAggregatesFilter | number | null
    precio?: IntNullableWithAggregatesFilter | number | null
  }

  export type clienteCreateInput = {
    nombre?: string | null
    apellido?: string | null
    telefono?: number | null
    direccion?: string | null
    abono?: abonoCreateNestedManyWithoutClienteInput
    eventos?: eventosCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    telefono?: number | null
    direccion?: string | null
    abono?: abonoUncheckedCreateNestedManyWithoutClienteInput
    eventos?: eventosUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    abono?: abonoUpdateManyWithoutClienteInput
    eventos?: eventosUpdateManyWithoutClienteInput
  }

  export type clienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    abono?: abonoUncheckedUpdateManyWithoutClienteInput
    eventos?: eventosUncheckedUpdateManyWithoutClienteInput
  }

  export type clienteCreateManyInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    telefono?: number | null
    direccion?: string | null
  }

  export type clienteUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventosCreateInput = {
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    cliente?: clienteCreateNestedOneWithoutEventosInput
    paqueteevento?: paqueteeventoCreateNestedOneWithoutEventosInput
    gastoseventos?: gastoseventosCreateNestedManyWithoutEventosInput
    pagos?: pagosCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosCreateNestedManyWithoutEventosInput
  }

  export type eventosUncheckedCreateInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idpaquete?: number | null
    idcliente?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    gastoseventos?: gastoseventosUncheckedCreateNestedManyWithoutEventosInput
    pagos?: pagosUncheckedCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutEventosInput
  }

  export type eventosUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cliente?: clienteUpdateOneWithoutEventosInput
    paqueteevento?: paqueteeventoUpdateOneWithoutEventosInput
    gastoseventos?: gastoseventosUpdateManyWithoutEventosInput
    pagos?: pagosUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUpdateManyWithoutEventosInput
  }

  export type eventosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gastoseventos?: gastoseventosUncheckedUpdateManyWithoutEventosInput
    pagos?: pagosUncheckedUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutEventosInput
  }

  export type eventosCreateManyInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idpaquete?: number | null
    idcliente?: number | null
    celebracion?: string | null
    pagado?: boolean | null
  }

  export type eventosUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type eventosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paqueteCreateInput = {
    nombre?: string | null
    adultos?: number | null
    ninios?: number | null
    precio?: number | null
    preciounitario?: number | null
    paqueteevento?: paqueteeventoCreateNestedManyWithoutPaqueteInput
  }

  export type paqueteUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    adultos?: number | null
    ninios?: number | null
    precio?: number | null
    preciounitario?: number | null
    paqueteevento?: paqueteeventoUncheckedCreateNestedManyWithoutPaqueteInput
  }

  export type paqueteUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    preciounitario?: NullableIntFieldUpdateOperationsInput | number | null
    paqueteevento?: paqueteeventoUpdateManyWithoutPaqueteInput
  }

  export type paqueteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    preciounitario?: NullableIntFieldUpdateOperationsInput | number | null
    paqueteevento?: paqueteeventoUncheckedUpdateManyWithoutPaqueteInput
  }

  export type paqueteCreateManyInput = {
    id?: number
    nombre?: string | null
    adultos?: number | null
    ninios?: number | null
    precio?: number | null
    preciounitario?: number | null
  }

  export type paqueteUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    preciounitario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paqueteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    preciounitario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paqueteeventoCreateInput = {
    adultos?: number | null
    ninios?: number | null
    total?: number | null
    paquete?: paqueteCreateNestedOneWithoutPaqueteeventoInput
    eventos?: eventosCreateNestedManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoUncheckedCreateInput = {
    id?: number
    adultos?: number | null
    ninios?: number | null
    total?: number | null
    idpaquete?: number | null
    eventos?: eventosUncheckedCreateNestedManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoUpdateInput = {
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    paquete?: paqueteUpdateOneWithoutPaqueteeventoInput
    eventos?: eventosUpdateManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    eventos?: eventosUncheckedUpdateManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoCreateManyInput = {
    id?: number
    adultos?: number | null
    ninios?: number | null
    total?: number | null
    idpaquete?: number | null
  }

  export type paqueteeventoUpdateManyMutationInput = {
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paqueteeventoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type abonoCreateInput = {
    fecha?: Date | string | null
    cantidad?: number | null
    cliente?: clienteCreateNestedOneWithoutAbonoInput
    pagos?: pagosCreateNestedOneWithoutAbonoInput
  }

  export type abonoUncheckedCreateInput = {
    id?: number
    fecha?: Date | string | null
    cantidad?: number | null
    idcliente?: number | null
    idpagos?: number | null
  }

  export type abonoUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    cliente?: clienteUpdateOneWithoutAbonoInput
    pagos?: pagosUpdateOneWithoutAbonoInput
  }

  export type abonoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    idpagos?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type abonoCreateManyInput = {
    id?: number
    fecha?: Date | string | null
    cantidad?: number | null
    idcliente?: number | null
    idpagos?: number | null
  }

  export type abonoUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type abonoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    idpagos?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empleadosCreateInput = {
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
    rol?: rolCreateNestedOneWithoutEmpleadosInput
    servicioseventos?: servicioseventosCreateNestedManyWithoutEmpleadosInput
  }

  export type empleadosUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
    idrol?: number | null
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutEmpleadosInput
  }

  export type empleadosUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: rolUpdateOneWithoutEmpleadosInput
    servicioseventos?: servicioseventosUpdateManyWithoutEmpleadosInput
  }

  export type empleadosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idrol?: NullableIntFieldUpdateOperationsInput | number | null
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutEmpleadosInput
  }

  export type empleadosCreateManyInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
    idrol?: number | null
  }

  export type empleadosUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empleadosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idrol?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastofijoCreateInput = {
    nombre?: string | null
    descripcion?: string | null
    total?: number | null
    activo?: boolean | null
    idmes?: number | null
  }

  export type gastofijoUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    total?: number | null
    activo?: boolean | null
    idmes?: number | null
  }

  export type gastofijoUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastofijoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastofijoCreateManyInput = {
    id?: number
    nombre?: string | null
    descripcion?: string | null
    total?: number | null
    activo?: boolean | null
    idmes?: number | null
  }

  export type gastofijoUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastofijoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastoseventosCreateInput = {
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    eventos?: eventosCreateNestedOneWithoutGastoseventosInput
    mes?: mesCreateNestedOneWithoutGastoseventosInput
  }

  export type gastoseventosUncheckedCreateInput = {
    id?: number
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    idmes?: number | null
    idevento?: number | null
  }

  export type gastoseventosUpdateInput = {
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: eventosUpdateOneWithoutGastoseventosInput
    mes?: mesUpdateOneWithoutGastoseventosInput
  }

  export type gastoseventosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastoseventosCreateManyInput = {
    id?: number
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    idmes?: number | null
    idevento?: number | null
  }

  export type gastoseventosUpdateManyMutationInput = {
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gastoseventosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mesCreateInput = {
    mes?: Date | string | null
    gastos?: number | null
    ganancias?: number | null
    gastoseventos?: gastoseventosCreateNestedManyWithoutMesInput
  }

  export type mesUncheckedCreateInput = {
    id?: number
    mes?: Date | string | null
    gastos?: number | null
    ganancias?: number | null
    gastoseventos?: gastoseventosUncheckedCreateNestedManyWithoutMesInput
  }

  export type mesUpdateInput = {
    mes?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableIntFieldUpdateOperationsInput | number | null
    ganancias?: NullableIntFieldUpdateOperationsInput | number | null
    gastoseventos?: gastoseventosUpdateManyWithoutMesInput
  }

  export type mesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mes?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableIntFieldUpdateOperationsInput | number | null
    ganancias?: NullableIntFieldUpdateOperationsInput | number | null
    gastoseventos?: gastoseventosUncheckedUpdateManyWithoutMesInput
  }

  export type mesCreateManyInput = {
    id?: number
    mes?: Date | string | null
    gastos?: number | null
    ganancias?: number | null
  }

  export type mesUpdateManyMutationInput = {
    mes?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableIntFieldUpdateOperationsInput | number | null
    ganancias?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mes?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableIntFieldUpdateOperationsInput | number | null
    ganancias?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pagosCreateInput = {
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
    eventos?: eventosCreateNestedOneWithoutPagosInput
    abono?: abonoCreateNestedManyWithoutPagosInput
  }

  export type pagosUncheckedCreateInput = {
    id?: number
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
    idevento?: number | null
    abono?: abonoUncheckedCreateNestedManyWithoutPagosInput
  }

  export type pagosUpdateInput = {
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventos?: eventosUpdateOneWithoutPagosInput
    abono?: abonoUpdateManyWithoutPagosInput
  }

  export type pagosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
    abono?: abonoUncheckedUpdateManyWithoutPagosInput
  }

  export type pagosCreateManyInput = {
    id?: number
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
    idevento?: number | null
  }

  export type pagosUpdateManyMutationInput = {
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pagosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolCreateInput = {
    rol?: string | null
    empleados?: empleadosCreateNestedManyWithoutRolInput
  }

  export type rolUncheckedCreateInput = {
    id?: number
    rol?: string | null
    empleados?: empleadosUncheckedCreateNestedManyWithoutRolInput
  }

  export type rolUpdateInput = {
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    empleados?: empleadosUpdateManyWithoutRolInput
  }

  export type rolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    empleados?: empleadosUncheckedUpdateManyWithoutRolInput
  }

  export type rolCreateManyInput = {
    id?: number
    rol?: string | null
  }

  export type rolUpdateManyMutationInput = {
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosCreateInput = {
    nombre?: string | null
    precio?: number | null
    descripcion?: string | null
    servicioseventos?: servicioseventosCreateNestedManyWithoutServiciosInput
  }

  export type serviciosUncheckedCreateInput = {
    id?: number
    nombre?: string | null
    precio?: number | null
    descripcion?: string | null
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutServiciosInput
  }

  export type serviciosUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    servicioseventos?: servicioseventosUpdateManyWithoutServiciosInput
  }

  export type serviciosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutServiciosInput
  }

  export type serviciosCreateManyInput = {
    id?: number
    nombre?: string | null
    precio?: number | null
    descripcion?: string | null
  }

  export type serviciosUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicioseventosCreateInput = {
    precio?: number | null
    empleados?: empleadosCreateNestedOneWithoutServicioseventosInput
    eventos?: eventosCreateNestedOneWithoutServicioseventosInput
    servicios?: serviciosCreateNestedOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedCreateInput = {
    id?: number
    idevento?: number | null
    idservicio?: number | null
    idempleado?: number | null
    precio?: number | null
  }

  export type servicioseventosUpdateInput = {
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    empleados?: empleadosUpdateOneWithoutServicioseventosInput
    eventos?: eventosUpdateOneWithoutServicioseventosInput
    servicios?: serviciosUpdateOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    idempleado?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicioseventosCreateManyInput = {
    id?: number
    idevento?: number | null
    idservicio?: number | null
    idempleado?: number | null
    precio?: number | null
  }

  export type servicioseventosUpdateManyMutationInput = {
    precio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicioseventosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    idempleado?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type AbonoListRelationFilter = {
    every?: abonoWhereInput
    some?: abonoWhereInput
    none?: abonoWhereInput
  }

  export type EventosListRelationFilter = {
    every?: eventosWhereInput
    some?: eventosWhereInput
    none?: eventosWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type ClienteRelationFilter = {
    is?: clienteWhereInput | null
    isNot?: clienteWhereInput | null
  }

  export type PaqueteeventoRelationFilter = {
    is?: paqueteeventoWhereInput | null
    isNot?: paqueteeventoWhereInput | null
  }

  export type GastoseventosListRelationFilter = {
    every?: gastoseventosWhereInput
    some?: gastoseventosWhereInput
    none?: gastoseventosWhereInput
  }

  export type PagosListRelationFilter = {
    every?: pagosWhereInput
    some?: pagosWhereInput
    none?: pagosWhereInput
  }

  export type ServicioseventosListRelationFilter = {
    every?: servicioseventosWhereInput
    some?: servicioseventosWhereInput
    none?: servicioseventosWhereInput
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type PaqueteeventoListRelationFilter = {
    every?: paqueteeventoWhereInput
    some?: paqueteeventoWhereInput
    none?: paqueteeventoWhereInput
  }

  export type PaqueteRelationFilter = {
    is?: paqueteWhereInput | null
    isNot?: paqueteWhereInput | null
  }

  export type PagosRelationFilter = {
    is?: pagosWhereInput | null
    isNot?: pagosWhereInput | null
  }

  export type RolRelationFilter = {
    is?: rolWhereInput | null
    isNot?: rolWhereInput | null
  }

  export type EventosRelationFilter = {
    is?: eventosWhereInput | null
    isNot?: eventosWhereInput | null
  }

  export type MesRelationFilter = {
    is?: mesWhereInput | null
    isNot?: mesWhereInput | null
  }

  export type EmpleadosListRelationFilter = {
    every?: empleadosWhereInput
    some?: empleadosWhereInput
    none?: empleadosWhereInput
  }

  export type EmpleadosRelationFilter = {
    is?: empleadosWhereInput | null
    isNot?: empleadosWhereInput | null
  }

  export type ServiciosRelationFilter = {
    is?: serviciosWhereInput | null
    isNot?: serviciosWhereInput | null
  }

  export type abonoCreateNestedManyWithoutClienteInput = {
    create?: XOR<Enumerable<abonoCreateWithoutClienteInput>, Enumerable<abonoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutClienteInput>
    createMany?: abonoCreateManyClienteInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
  }

  export type eventosCreateNestedManyWithoutClienteInput = {
    create?: XOR<Enumerable<eventosCreateWithoutClienteInput>, Enumerable<eventosUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutClienteInput>
    createMany?: eventosCreateManyClienteInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
  }

  export type abonoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<Enumerable<abonoCreateWithoutClienteInput>, Enumerable<abonoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutClienteInput>
    createMany?: abonoCreateManyClienteInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
  }

  export type eventosUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<Enumerable<eventosCreateWithoutClienteInput>, Enumerable<eventosUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutClienteInput>
    createMany?: eventosCreateManyClienteInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type abonoUpdateManyWithoutClienteInput = {
    create?: XOR<Enumerable<abonoCreateWithoutClienteInput>, Enumerable<abonoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutClienteInput>
    upsert?: Enumerable<abonoUpsertWithWhereUniqueWithoutClienteInput>
    createMany?: abonoCreateManyClienteInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
    set?: Enumerable<abonoWhereUniqueInput>
    disconnect?: Enumerable<abonoWhereUniqueInput>
    delete?: Enumerable<abonoWhereUniqueInput>
    update?: Enumerable<abonoUpdateWithWhereUniqueWithoutClienteInput>
    updateMany?: Enumerable<abonoUpdateManyWithWhereWithoutClienteInput>
    deleteMany?: Enumerable<abonoScalarWhereInput>
  }

  export type eventosUpdateManyWithoutClienteInput = {
    create?: XOR<Enumerable<eventosCreateWithoutClienteInput>, Enumerable<eventosUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutClienteInput>
    upsert?: Enumerable<eventosUpsertWithWhereUniqueWithoutClienteInput>
    createMany?: eventosCreateManyClienteInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
    set?: Enumerable<eventosWhereUniqueInput>
    disconnect?: Enumerable<eventosWhereUniqueInput>
    delete?: Enumerable<eventosWhereUniqueInput>
    update?: Enumerable<eventosUpdateWithWhereUniqueWithoutClienteInput>
    updateMany?: Enumerable<eventosUpdateManyWithWhereWithoutClienteInput>
    deleteMany?: Enumerable<eventosScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type abonoUncheckedUpdateManyWithoutClienteInput = {
    create?: XOR<Enumerable<abonoCreateWithoutClienteInput>, Enumerable<abonoUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutClienteInput>
    upsert?: Enumerable<abonoUpsertWithWhereUniqueWithoutClienteInput>
    createMany?: abonoCreateManyClienteInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
    set?: Enumerable<abonoWhereUniqueInput>
    disconnect?: Enumerable<abonoWhereUniqueInput>
    delete?: Enumerable<abonoWhereUniqueInput>
    update?: Enumerable<abonoUpdateWithWhereUniqueWithoutClienteInput>
    updateMany?: Enumerable<abonoUpdateManyWithWhereWithoutClienteInput>
    deleteMany?: Enumerable<abonoScalarWhereInput>
  }

  export type eventosUncheckedUpdateManyWithoutClienteInput = {
    create?: XOR<Enumerable<eventosCreateWithoutClienteInput>, Enumerable<eventosUncheckedCreateWithoutClienteInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutClienteInput>
    upsert?: Enumerable<eventosUpsertWithWhereUniqueWithoutClienteInput>
    createMany?: eventosCreateManyClienteInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
    set?: Enumerable<eventosWhereUniqueInput>
    disconnect?: Enumerable<eventosWhereUniqueInput>
    delete?: Enumerable<eventosWhereUniqueInput>
    update?: Enumerable<eventosUpdateWithWhereUniqueWithoutClienteInput>
    updateMany?: Enumerable<eventosUpdateManyWithWhereWithoutClienteInput>
    deleteMany?: Enumerable<eventosScalarWhereInput>
  }

  export type clienteCreateNestedOneWithoutEventosInput = {
    create?: XOR<clienteCreateWithoutEventosInput, clienteUncheckedCreateWithoutEventosInput>
    connectOrCreate?: clienteCreateOrConnectWithoutEventosInput
    connect?: clienteWhereUniqueInput
  }

  export type paqueteeventoCreateNestedOneWithoutEventosInput = {
    create?: XOR<paqueteeventoCreateWithoutEventosInput, paqueteeventoUncheckedCreateWithoutEventosInput>
    connectOrCreate?: paqueteeventoCreateOrConnectWithoutEventosInput
    connect?: paqueteeventoWhereUniqueInput
  }

  export type gastoseventosCreateNestedManyWithoutEventosInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutEventosInput>, Enumerable<gastoseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutEventosInput>
    createMany?: gastoseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
  }

  export type pagosCreateNestedManyWithoutEventosInput = {
    create?: XOR<Enumerable<pagosCreateWithoutEventosInput>, Enumerable<pagosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<pagosCreateOrConnectWithoutEventosInput>
    createMany?: pagosCreateManyEventosInputEnvelope
    connect?: Enumerable<pagosWhereUniqueInput>
  }

  export type servicioseventosCreateNestedManyWithoutEventosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEventosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEventosInput>
    createMany?: servicioseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
  }

  export type gastoseventosUncheckedCreateNestedManyWithoutEventosInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutEventosInput>, Enumerable<gastoseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutEventosInput>
    createMany?: gastoseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
  }

  export type pagosUncheckedCreateNestedManyWithoutEventosInput = {
    create?: XOR<Enumerable<pagosCreateWithoutEventosInput>, Enumerable<pagosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<pagosCreateOrConnectWithoutEventosInput>
    createMany?: pagosCreateManyEventosInputEnvelope
    connect?: Enumerable<pagosWhereUniqueInput>
  }

  export type servicioseventosUncheckedCreateNestedManyWithoutEventosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEventosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEventosInput>
    createMany?: servicioseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type clienteUpdateOneWithoutEventosInput = {
    create?: XOR<clienteCreateWithoutEventosInput, clienteUncheckedCreateWithoutEventosInput>
    connectOrCreate?: clienteCreateOrConnectWithoutEventosInput
    upsert?: clienteUpsertWithoutEventosInput
    connect?: clienteWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<clienteUpdateWithoutEventosInput, clienteUncheckedUpdateWithoutEventosInput>
  }

  export type paqueteeventoUpdateOneWithoutEventosInput = {
    create?: XOR<paqueteeventoCreateWithoutEventosInput, paqueteeventoUncheckedCreateWithoutEventosInput>
    connectOrCreate?: paqueteeventoCreateOrConnectWithoutEventosInput
    upsert?: paqueteeventoUpsertWithoutEventosInput
    connect?: paqueteeventoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<paqueteeventoUpdateWithoutEventosInput, paqueteeventoUncheckedUpdateWithoutEventosInput>
  }

  export type gastoseventosUpdateManyWithoutEventosInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutEventosInput>, Enumerable<gastoseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutEventosInput>
    upsert?: Enumerable<gastoseventosUpsertWithWhereUniqueWithoutEventosInput>
    createMany?: gastoseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
    set?: Enumerable<gastoseventosWhereUniqueInput>
    disconnect?: Enumerable<gastoseventosWhereUniqueInput>
    delete?: Enumerable<gastoseventosWhereUniqueInput>
    update?: Enumerable<gastoseventosUpdateWithWhereUniqueWithoutEventosInput>
    updateMany?: Enumerable<gastoseventosUpdateManyWithWhereWithoutEventosInput>
    deleteMany?: Enumerable<gastoseventosScalarWhereInput>
  }

  export type pagosUpdateManyWithoutEventosInput = {
    create?: XOR<Enumerable<pagosCreateWithoutEventosInput>, Enumerable<pagosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<pagosCreateOrConnectWithoutEventosInput>
    upsert?: Enumerable<pagosUpsertWithWhereUniqueWithoutEventosInput>
    createMany?: pagosCreateManyEventosInputEnvelope
    connect?: Enumerable<pagosWhereUniqueInput>
    set?: Enumerable<pagosWhereUniqueInput>
    disconnect?: Enumerable<pagosWhereUniqueInput>
    delete?: Enumerable<pagosWhereUniqueInput>
    update?: Enumerable<pagosUpdateWithWhereUniqueWithoutEventosInput>
    updateMany?: Enumerable<pagosUpdateManyWithWhereWithoutEventosInput>
    deleteMany?: Enumerable<pagosScalarWhereInput>
  }

  export type servicioseventosUpdateManyWithoutEventosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEventosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEventosInput>
    upsert?: Enumerable<servicioseventosUpsertWithWhereUniqueWithoutEventosInput>
    createMany?: servicioseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
    set?: Enumerable<servicioseventosWhereUniqueInput>
    disconnect?: Enumerable<servicioseventosWhereUniqueInput>
    delete?: Enumerable<servicioseventosWhereUniqueInput>
    update?: Enumerable<servicioseventosUpdateWithWhereUniqueWithoutEventosInput>
    updateMany?: Enumerable<servicioseventosUpdateManyWithWhereWithoutEventosInput>
    deleteMany?: Enumerable<servicioseventosScalarWhereInput>
  }

  export type gastoseventosUncheckedUpdateManyWithoutEventosInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutEventosInput>, Enumerable<gastoseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutEventosInput>
    upsert?: Enumerable<gastoseventosUpsertWithWhereUniqueWithoutEventosInput>
    createMany?: gastoseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
    set?: Enumerable<gastoseventosWhereUniqueInput>
    disconnect?: Enumerable<gastoseventosWhereUniqueInput>
    delete?: Enumerable<gastoseventosWhereUniqueInput>
    update?: Enumerable<gastoseventosUpdateWithWhereUniqueWithoutEventosInput>
    updateMany?: Enumerable<gastoseventosUpdateManyWithWhereWithoutEventosInput>
    deleteMany?: Enumerable<gastoseventosScalarWhereInput>
  }

  export type pagosUncheckedUpdateManyWithoutEventosInput = {
    create?: XOR<Enumerable<pagosCreateWithoutEventosInput>, Enumerable<pagosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<pagosCreateOrConnectWithoutEventosInput>
    upsert?: Enumerable<pagosUpsertWithWhereUniqueWithoutEventosInput>
    createMany?: pagosCreateManyEventosInputEnvelope
    connect?: Enumerable<pagosWhereUniqueInput>
    set?: Enumerable<pagosWhereUniqueInput>
    disconnect?: Enumerable<pagosWhereUniqueInput>
    delete?: Enumerable<pagosWhereUniqueInput>
    update?: Enumerable<pagosUpdateWithWhereUniqueWithoutEventosInput>
    updateMany?: Enumerable<pagosUpdateManyWithWhereWithoutEventosInput>
    deleteMany?: Enumerable<pagosScalarWhereInput>
  }

  export type servicioseventosUncheckedUpdateManyWithoutEventosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEventosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEventosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEventosInput>
    upsert?: Enumerable<servicioseventosUpsertWithWhereUniqueWithoutEventosInput>
    createMany?: servicioseventosCreateManyEventosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
    set?: Enumerable<servicioseventosWhereUniqueInput>
    disconnect?: Enumerable<servicioseventosWhereUniqueInput>
    delete?: Enumerable<servicioseventosWhereUniqueInput>
    update?: Enumerable<servicioseventosUpdateWithWhereUniqueWithoutEventosInput>
    updateMany?: Enumerable<servicioseventosUpdateManyWithWhereWithoutEventosInput>
    deleteMany?: Enumerable<servicioseventosScalarWhereInput>
  }

  export type paqueteeventoCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<Enumerable<paqueteeventoCreateWithoutPaqueteInput>, Enumerable<paqueteeventoUncheckedCreateWithoutPaqueteInput>>
    connectOrCreate?: Enumerable<paqueteeventoCreateOrConnectWithoutPaqueteInput>
    createMany?: paqueteeventoCreateManyPaqueteInputEnvelope
    connect?: Enumerable<paqueteeventoWhereUniqueInput>
  }

  export type paqueteeventoUncheckedCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<Enumerable<paqueteeventoCreateWithoutPaqueteInput>, Enumerable<paqueteeventoUncheckedCreateWithoutPaqueteInput>>
    connectOrCreate?: Enumerable<paqueteeventoCreateOrConnectWithoutPaqueteInput>
    createMany?: paqueteeventoCreateManyPaqueteInputEnvelope
    connect?: Enumerable<paqueteeventoWhereUniqueInput>
  }

  export type paqueteeventoUpdateManyWithoutPaqueteInput = {
    create?: XOR<Enumerable<paqueteeventoCreateWithoutPaqueteInput>, Enumerable<paqueteeventoUncheckedCreateWithoutPaqueteInput>>
    connectOrCreate?: Enumerable<paqueteeventoCreateOrConnectWithoutPaqueteInput>
    upsert?: Enumerable<paqueteeventoUpsertWithWhereUniqueWithoutPaqueteInput>
    createMany?: paqueteeventoCreateManyPaqueteInputEnvelope
    connect?: Enumerable<paqueteeventoWhereUniqueInput>
    set?: Enumerable<paqueteeventoWhereUniqueInput>
    disconnect?: Enumerable<paqueteeventoWhereUniqueInput>
    delete?: Enumerable<paqueteeventoWhereUniqueInput>
    update?: Enumerable<paqueteeventoUpdateWithWhereUniqueWithoutPaqueteInput>
    updateMany?: Enumerable<paqueteeventoUpdateManyWithWhereWithoutPaqueteInput>
    deleteMany?: Enumerable<paqueteeventoScalarWhereInput>
  }

  export type paqueteeventoUncheckedUpdateManyWithoutPaqueteInput = {
    create?: XOR<Enumerable<paqueteeventoCreateWithoutPaqueteInput>, Enumerable<paqueteeventoUncheckedCreateWithoutPaqueteInput>>
    connectOrCreate?: Enumerable<paqueteeventoCreateOrConnectWithoutPaqueteInput>
    upsert?: Enumerable<paqueteeventoUpsertWithWhereUniqueWithoutPaqueteInput>
    createMany?: paqueteeventoCreateManyPaqueteInputEnvelope
    connect?: Enumerable<paqueteeventoWhereUniqueInput>
    set?: Enumerable<paqueteeventoWhereUniqueInput>
    disconnect?: Enumerable<paqueteeventoWhereUniqueInput>
    delete?: Enumerable<paqueteeventoWhereUniqueInput>
    update?: Enumerable<paqueteeventoUpdateWithWhereUniqueWithoutPaqueteInput>
    updateMany?: Enumerable<paqueteeventoUpdateManyWithWhereWithoutPaqueteInput>
    deleteMany?: Enumerable<paqueteeventoScalarWhereInput>
  }

  export type paqueteCreateNestedOneWithoutPaqueteeventoInput = {
    create?: XOR<paqueteCreateWithoutPaqueteeventoInput, paqueteUncheckedCreateWithoutPaqueteeventoInput>
    connectOrCreate?: paqueteCreateOrConnectWithoutPaqueteeventoInput
    connect?: paqueteWhereUniqueInput
  }

  export type eventosCreateNestedManyWithoutPaqueteeventoInput = {
    create?: XOR<Enumerable<eventosCreateWithoutPaqueteeventoInput>, Enumerable<eventosUncheckedCreateWithoutPaqueteeventoInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutPaqueteeventoInput>
    createMany?: eventosCreateManyPaqueteeventoInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
  }

  export type eventosUncheckedCreateNestedManyWithoutPaqueteeventoInput = {
    create?: XOR<Enumerable<eventosCreateWithoutPaqueteeventoInput>, Enumerable<eventosUncheckedCreateWithoutPaqueteeventoInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutPaqueteeventoInput>
    createMany?: eventosCreateManyPaqueteeventoInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
  }

  export type paqueteUpdateOneWithoutPaqueteeventoInput = {
    create?: XOR<paqueteCreateWithoutPaqueteeventoInput, paqueteUncheckedCreateWithoutPaqueteeventoInput>
    connectOrCreate?: paqueteCreateOrConnectWithoutPaqueteeventoInput
    upsert?: paqueteUpsertWithoutPaqueteeventoInput
    connect?: paqueteWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<paqueteUpdateWithoutPaqueteeventoInput, paqueteUncheckedUpdateWithoutPaqueteeventoInput>
  }

  export type eventosUpdateManyWithoutPaqueteeventoInput = {
    create?: XOR<Enumerable<eventosCreateWithoutPaqueteeventoInput>, Enumerable<eventosUncheckedCreateWithoutPaqueteeventoInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutPaqueteeventoInput>
    upsert?: Enumerable<eventosUpsertWithWhereUniqueWithoutPaqueteeventoInput>
    createMany?: eventosCreateManyPaqueteeventoInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
    set?: Enumerable<eventosWhereUniqueInput>
    disconnect?: Enumerable<eventosWhereUniqueInput>
    delete?: Enumerable<eventosWhereUniqueInput>
    update?: Enumerable<eventosUpdateWithWhereUniqueWithoutPaqueteeventoInput>
    updateMany?: Enumerable<eventosUpdateManyWithWhereWithoutPaqueteeventoInput>
    deleteMany?: Enumerable<eventosScalarWhereInput>
  }

  export type eventosUncheckedUpdateManyWithoutPaqueteeventoInput = {
    create?: XOR<Enumerable<eventosCreateWithoutPaqueteeventoInput>, Enumerable<eventosUncheckedCreateWithoutPaqueteeventoInput>>
    connectOrCreate?: Enumerable<eventosCreateOrConnectWithoutPaqueteeventoInput>
    upsert?: Enumerable<eventosUpsertWithWhereUniqueWithoutPaqueteeventoInput>
    createMany?: eventosCreateManyPaqueteeventoInputEnvelope
    connect?: Enumerable<eventosWhereUniqueInput>
    set?: Enumerable<eventosWhereUniqueInput>
    disconnect?: Enumerable<eventosWhereUniqueInput>
    delete?: Enumerable<eventosWhereUniqueInput>
    update?: Enumerable<eventosUpdateWithWhereUniqueWithoutPaqueteeventoInput>
    updateMany?: Enumerable<eventosUpdateManyWithWhereWithoutPaqueteeventoInput>
    deleteMany?: Enumerable<eventosScalarWhereInput>
  }

  export type clienteCreateNestedOneWithoutAbonoInput = {
    create?: XOR<clienteCreateWithoutAbonoInput, clienteUncheckedCreateWithoutAbonoInput>
    connectOrCreate?: clienteCreateOrConnectWithoutAbonoInput
    connect?: clienteWhereUniqueInput
  }

  export type pagosCreateNestedOneWithoutAbonoInput = {
    create?: XOR<pagosCreateWithoutAbonoInput, pagosUncheckedCreateWithoutAbonoInput>
    connectOrCreate?: pagosCreateOrConnectWithoutAbonoInput
    connect?: pagosWhereUniqueInput
  }

  export type clienteUpdateOneWithoutAbonoInput = {
    create?: XOR<clienteCreateWithoutAbonoInput, clienteUncheckedCreateWithoutAbonoInput>
    connectOrCreate?: clienteCreateOrConnectWithoutAbonoInput
    upsert?: clienteUpsertWithoutAbonoInput
    connect?: clienteWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<clienteUpdateWithoutAbonoInput, clienteUncheckedUpdateWithoutAbonoInput>
  }

  export type pagosUpdateOneWithoutAbonoInput = {
    create?: XOR<pagosCreateWithoutAbonoInput, pagosUncheckedCreateWithoutAbonoInput>
    connectOrCreate?: pagosCreateOrConnectWithoutAbonoInput
    upsert?: pagosUpsertWithoutAbonoInput
    connect?: pagosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<pagosUpdateWithoutAbonoInput, pagosUncheckedUpdateWithoutAbonoInput>
  }

  export type rolCreateNestedOneWithoutEmpleadosInput = {
    create?: XOR<rolCreateWithoutEmpleadosInput, rolUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: rolCreateOrConnectWithoutEmpleadosInput
    connect?: rolWhereUniqueInput
  }

  export type servicioseventosCreateNestedManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEmpleadosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEmpleadosInput>
    createMany?: servicioseventosCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
  }

  export type servicioseventosUncheckedCreateNestedManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEmpleadosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEmpleadosInput>
    createMany?: servicioseventosCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
  }

  export type rolUpdateOneWithoutEmpleadosInput = {
    create?: XOR<rolCreateWithoutEmpleadosInput, rolUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: rolCreateOrConnectWithoutEmpleadosInput
    upsert?: rolUpsertWithoutEmpleadosInput
    connect?: rolWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<rolUpdateWithoutEmpleadosInput, rolUncheckedUpdateWithoutEmpleadosInput>
  }

  export type servicioseventosUpdateManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEmpleadosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEmpleadosInput>
    upsert?: Enumerable<servicioseventosUpsertWithWhereUniqueWithoutEmpleadosInput>
    createMany?: servicioseventosCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
    set?: Enumerable<servicioseventosWhereUniqueInput>
    disconnect?: Enumerable<servicioseventosWhereUniqueInput>
    delete?: Enumerable<servicioseventosWhereUniqueInput>
    update?: Enumerable<servicioseventosUpdateWithWhereUniqueWithoutEmpleadosInput>
    updateMany?: Enumerable<servicioseventosUpdateManyWithWhereWithoutEmpleadosInput>
    deleteMany?: Enumerable<servicioseventosScalarWhereInput>
  }

  export type servicioseventosUncheckedUpdateManyWithoutEmpleadosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutEmpleadosInput>, Enumerable<servicioseventosUncheckedCreateWithoutEmpleadosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutEmpleadosInput>
    upsert?: Enumerable<servicioseventosUpsertWithWhereUniqueWithoutEmpleadosInput>
    createMany?: servicioseventosCreateManyEmpleadosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
    set?: Enumerable<servicioseventosWhereUniqueInput>
    disconnect?: Enumerable<servicioseventosWhereUniqueInput>
    delete?: Enumerable<servicioseventosWhereUniqueInput>
    update?: Enumerable<servicioseventosUpdateWithWhereUniqueWithoutEmpleadosInput>
    updateMany?: Enumerable<servicioseventosUpdateManyWithWhereWithoutEmpleadosInput>
    deleteMany?: Enumerable<servicioseventosScalarWhereInput>
  }

  export type eventosCreateNestedOneWithoutGastoseventosInput = {
    create?: XOR<eventosCreateWithoutGastoseventosInput, eventosUncheckedCreateWithoutGastoseventosInput>
    connectOrCreate?: eventosCreateOrConnectWithoutGastoseventosInput
    connect?: eventosWhereUniqueInput
  }

  export type mesCreateNestedOneWithoutGastoseventosInput = {
    create?: XOR<mesCreateWithoutGastoseventosInput, mesUncheckedCreateWithoutGastoseventosInput>
    connectOrCreate?: mesCreateOrConnectWithoutGastoseventosInput
    connect?: mesWhereUniqueInput
  }

  export type eventosUpdateOneWithoutGastoseventosInput = {
    create?: XOR<eventosCreateWithoutGastoseventosInput, eventosUncheckedCreateWithoutGastoseventosInput>
    connectOrCreate?: eventosCreateOrConnectWithoutGastoseventosInput
    upsert?: eventosUpsertWithoutGastoseventosInput
    connect?: eventosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<eventosUpdateWithoutGastoseventosInput, eventosUncheckedUpdateWithoutGastoseventosInput>
  }

  export type mesUpdateOneWithoutGastoseventosInput = {
    create?: XOR<mesCreateWithoutGastoseventosInput, mesUncheckedCreateWithoutGastoseventosInput>
    connectOrCreate?: mesCreateOrConnectWithoutGastoseventosInput
    upsert?: mesUpsertWithoutGastoseventosInput
    connect?: mesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<mesUpdateWithoutGastoseventosInput, mesUncheckedUpdateWithoutGastoseventosInput>
  }

  export type gastoseventosCreateNestedManyWithoutMesInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutMesInput>, Enumerable<gastoseventosUncheckedCreateWithoutMesInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutMesInput>
    createMany?: gastoseventosCreateManyMesInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
  }

  export type gastoseventosUncheckedCreateNestedManyWithoutMesInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutMesInput>, Enumerable<gastoseventosUncheckedCreateWithoutMesInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutMesInput>
    createMany?: gastoseventosCreateManyMesInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
  }

  export type gastoseventosUpdateManyWithoutMesInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutMesInput>, Enumerable<gastoseventosUncheckedCreateWithoutMesInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutMesInput>
    upsert?: Enumerable<gastoseventosUpsertWithWhereUniqueWithoutMesInput>
    createMany?: gastoseventosCreateManyMesInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
    set?: Enumerable<gastoseventosWhereUniqueInput>
    disconnect?: Enumerable<gastoseventosWhereUniqueInput>
    delete?: Enumerable<gastoseventosWhereUniqueInput>
    update?: Enumerable<gastoseventosUpdateWithWhereUniqueWithoutMesInput>
    updateMany?: Enumerable<gastoseventosUpdateManyWithWhereWithoutMesInput>
    deleteMany?: Enumerable<gastoseventosScalarWhereInput>
  }

  export type gastoseventosUncheckedUpdateManyWithoutMesInput = {
    create?: XOR<Enumerable<gastoseventosCreateWithoutMesInput>, Enumerable<gastoseventosUncheckedCreateWithoutMesInput>>
    connectOrCreate?: Enumerable<gastoseventosCreateOrConnectWithoutMesInput>
    upsert?: Enumerable<gastoseventosUpsertWithWhereUniqueWithoutMesInput>
    createMany?: gastoseventosCreateManyMesInputEnvelope
    connect?: Enumerable<gastoseventosWhereUniqueInput>
    set?: Enumerable<gastoseventosWhereUniqueInput>
    disconnect?: Enumerable<gastoseventosWhereUniqueInput>
    delete?: Enumerable<gastoseventosWhereUniqueInput>
    update?: Enumerable<gastoseventosUpdateWithWhereUniqueWithoutMesInput>
    updateMany?: Enumerable<gastoseventosUpdateManyWithWhereWithoutMesInput>
    deleteMany?: Enumerable<gastoseventosScalarWhereInput>
  }

  export type eventosCreateNestedOneWithoutPagosInput = {
    create?: XOR<eventosCreateWithoutPagosInput, eventosUncheckedCreateWithoutPagosInput>
    connectOrCreate?: eventosCreateOrConnectWithoutPagosInput
    connect?: eventosWhereUniqueInput
  }

  export type abonoCreateNestedManyWithoutPagosInput = {
    create?: XOR<Enumerable<abonoCreateWithoutPagosInput>, Enumerable<abonoUncheckedCreateWithoutPagosInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutPagosInput>
    createMany?: abonoCreateManyPagosInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
  }

  export type abonoUncheckedCreateNestedManyWithoutPagosInput = {
    create?: XOR<Enumerable<abonoCreateWithoutPagosInput>, Enumerable<abonoUncheckedCreateWithoutPagosInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutPagosInput>
    createMany?: abonoCreateManyPagosInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
  }

  export type eventosUpdateOneWithoutPagosInput = {
    create?: XOR<eventosCreateWithoutPagosInput, eventosUncheckedCreateWithoutPagosInput>
    connectOrCreate?: eventosCreateOrConnectWithoutPagosInput
    upsert?: eventosUpsertWithoutPagosInput
    connect?: eventosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<eventosUpdateWithoutPagosInput, eventosUncheckedUpdateWithoutPagosInput>
  }

  export type abonoUpdateManyWithoutPagosInput = {
    create?: XOR<Enumerable<abonoCreateWithoutPagosInput>, Enumerable<abonoUncheckedCreateWithoutPagosInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutPagosInput>
    upsert?: Enumerable<abonoUpsertWithWhereUniqueWithoutPagosInput>
    createMany?: abonoCreateManyPagosInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
    set?: Enumerable<abonoWhereUniqueInput>
    disconnect?: Enumerable<abonoWhereUniqueInput>
    delete?: Enumerable<abonoWhereUniqueInput>
    update?: Enumerable<abonoUpdateWithWhereUniqueWithoutPagosInput>
    updateMany?: Enumerable<abonoUpdateManyWithWhereWithoutPagosInput>
    deleteMany?: Enumerable<abonoScalarWhereInput>
  }

  export type abonoUncheckedUpdateManyWithoutPagosInput = {
    create?: XOR<Enumerable<abonoCreateWithoutPagosInput>, Enumerable<abonoUncheckedCreateWithoutPagosInput>>
    connectOrCreate?: Enumerable<abonoCreateOrConnectWithoutPagosInput>
    upsert?: Enumerable<abonoUpsertWithWhereUniqueWithoutPagosInput>
    createMany?: abonoCreateManyPagosInputEnvelope
    connect?: Enumerable<abonoWhereUniqueInput>
    set?: Enumerable<abonoWhereUniqueInput>
    disconnect?: Enumerable<abonoWhereUniqueInput>
    delete?: Enumerable<abonoWhereUniqueInput>
    update?: Enumerable<abonoUpdateWithWhereUniqueWithoutPagosInput>
    updateMany?: Enumerable<abonoUpdateManyWithWhereWithoutPagosInput>
    deleteMany?: Enumerable<abonoScalarWhereInput>
  }

  export type empleadosCreateNestedManyWithoutRolInput = {
    create?: XOR<Enumerable<empleadosCreateWithoutRolInput>, Enumerable<empleadosUncheckedCreateWithoutRolInput>>
    connectOrCreate?: Enumerable<empleadosCreateOrConnectWithoutRolInput>
    createMany?: empleadosCreateManyRolInputEnvelope
    connect?: Enumerable<empleadosWhereUniqueInput>
  }

  export type empleadosUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<Enumerable<empleadosCreateWithoutRolInput>, Enumerable<empleadosUncheckedCreateWithoutRolInput>>
    connectOrCreate?: Enumerable<empleadosCreateOrConnectWithoutRolInput>
    createMany?: empleadosCreateManyRolInputEnvelope
    connect?: Enumerable<empleadosWhereUniqueInput>
  }

  export type empleadosUpdateManyWithoutRolInput = {
    create?: XOR<Enumerable<empleadosCreateWithoutRolInput>, Enumerable<empleadosUncheckedCreateWithoutRolInput>>
    connectOrCreate?: Enumerable<empleadosCreateOrConnectWithoutRolInput>
    upsert?: Enumerable<empleadosUpsertWithWhereUniqueWithoutRolInput>
    createMany?: empleadosCreateManyRolInputEnvelope
    connect?: Enumerable<empleadosWhereUniqueInput>
    set?: Enumerable<empleadosWhereUniqueInput>
    disconnect?: Enumerable<empleadosWhereUniqueInput>
    delete?: Enumerable<empleadosWhereUniqueInput>
    update?: Enumerable<empleadosUpdateWithWhereUniqueWithoutRolInput>
    updateMany?: Enumerable<empleadosUpdateManyWithWhereWithoutRolInput>
    deleteMany?: Enumerable<empleadosScalarWhereInput>
  }

  export type empleadosUncheckedUpdateManyWithoutRolInput = {
    create?: XOR<Enumerable<empleadosCreateWithoutRolInput>, Enumerable<empleadosUncheckedCreateWithoutRolInput>>
    connectOrCreate?: Enumerable<empleadosCreateOrConnectWithoutRolInput>
    upsert?: Enumerable<empleadosUpsertWithWhereUniqueWithoutRolInput>
    createMany?: empleadosCreateManyRolInputEnvelope
    connect?: Enumerable<empleadosWhereUniqueInput>
    set?: Enumerable<empleadosWhereUniqueInput>
    disconnect?: Enumerable<empleadosWhereUniqueInput>
    delete?: Enumerable<empleadosWhereUniqueInput>
    update?: Enumerable<empleadosUpdateWithWhereUniqueWithoutRolInput>
    updateMany?: Enumerable<empleadosUpdateManyWithWhereWithoutRolInput>
    deleteMany?: Enumerable<empleadosScalarWhereInput>
  }

  export type servicioseventosCreateNestedManyWithoutServiciosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutServiciosInput>, Enumerable<servicioseventosUncheckedCreateWithoutServiciosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutServiciosInput>
    createMany?: servicioseventosCreateManyServiciosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
  }

  export type servicioseventosUncheckedCreateNestedManyWithoutServiciosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutServiciosInput>, Enumerable<servicioseventosUncheckedCreateWithoutServiciosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutServiciosInput>
    createMany?: servicioseventosCreateManyServiciosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
  }

  export type servicioseventosUpdateManyWithoutServiciosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutServiciosInput>, Enumerable<servicioseventosUncheckedCreateWithoutServiciosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutServiciosInput>
    upsert?: Enumerable<servicioseventosUpsertWithWhereUniqueWithoutServiciosInput>
    createMany?: servicioseventosCreateManyServiciosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
    set?: Enumerable<servicioseventosWhereUniqueInput>
    disconnect?: Enumerable<servicioseventosWhereUniqueInput>
    delete?: Enumerable<servicioseventosWhereUniqueInput>
    update?: Enumerable<servicioseventosUpdateWithWhereUniqueWithoutServiciosInput>
    updateMany?: Enumerable<servicioseventosUpdateManyWithWhereWithoutServiciosInput>
    deleteMany?: Enumerable<servicioseventosScalarWhereInput>
  }

  export type servicioseventosUncheckedUpdateManyWithoutServiciosInput = {
    create?: XOR<Enumerable<servicioseventosCreateWithoutServiciosInput>, Enumerable<servicioseventosUncheckedCreateWithoutServiciosInput>>
    connectOrCreate?: Enumerable<servicioseventosCreateOrConnectWithoutServiciosInput>
    upsert?: Enumerable<servicioseventosUpsertWithWhereUniqueWithoutServiciosInput>
    createMany?: servicioseventosCreateManyServiciosInputEnvelope
    connect?: Enumerable<servicioseventosWhereUniqueInput>
    set?: Enumerable<servicioseventosWhereUniqueInput>
    disconnect?: Enumerable<servicioseventosWhereUniqueInput>
    delete?: Enumerable<servicioseventosWhereUniqueInput>
    update?: Enumerable<servicioseventosUpdateWithWhereUniqueWithoutServiciosInput>
    updateMany?: Enumerable<servicioseventosUpdateManyWithWhereWithoutServiciosInput>
    deleteMany?: Enumerable<servicioseventosScalarWhereInput>
  }

  export type empleadosCreateNestedOneWithoutServicioseventosInput = {
    create?: XOR<empleadosCreateWithoutServicioseventosInput, empleadosUncheckedCreateWithoutServicioseventosInput>
    connectOrCreate?: empleadosCreateOrConnectWithoutServicioseventosInput
    connect?: empleadosWhereUniqueInput
  }

  export type eventosCreateNestedOneWithoutServicioseventosInput = {
    create?: XOR<eventosCreateWithoutServicioseventosInput, eventosUncheckedCreateWithoutServicioseventosInput>
    connectOrCreate?: eventosCreateOrConnectWithoutServicioseventosInput
    connect?: eventosWhereUniqueInput
  }

  export type serviciosCreateNestedOneWithoutServicioseventosInput = {
    create?: XOR<serviciosCreateWithoutServicioseventosInput, serviciosUncheckedCreateWithoutServicioseventosInput>
    connectOrCreate?: serviciosCreateOrConnectWithoutServicioseventosInput
    connect?: serviciosWhereUniqueInput
  }

  export type empleadosUpdateOneWithoutServicioseventosInput = {
    create?: XOR<empleadosCreateWithoutServicioseventosInput, empleadosUncheckedCreateWithoutServicioseventosInput>
    connectOrCreate?: empleadosCreateOrConnectWithoutServicioseventosInput
    upsert?: empleadosUpsertWithoutServicioseventosInput
    connect?: empleadosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<empleadosUpdateWithoutServicioseventosInput, empleadosUncheckedUpdateWithoutServicioseventosInput>
  }

  export type eventosUpdateOneWithoutServicioseventosInput = {
    create?: XOR<eventosCreateWithoutServicioseventosInput, eventosUncheckedCreateWithoutServicioseventosInput>
    connectOrCreate?: eventosCreateOrConnectWithoutServicioseventosInput
    upsert?: eventosUpsertWithoutServicioseventosInput
    connect?: eventosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<eventosUpdateWithoutServicioseventosInput, eventosUncheckedUpdateWithoutServicioseventosInput>
  }

  export type serviciosUpdateOneWithoutServicioseventosInput = {
    create?: XOR<serviciosCreateWithoutServicioseventosInput, serviciosUncheckedCreateWithoutServicioseventosInput>
    connectOrCreate?: serviciosCreateOrConnectWithoutServicioseventosInput
    upsert?: serviciosUpsertWithoutServicioseventosInput
    connect?: serviciosWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<serviciosUpdateWithoutServicioseventosInput, serviciosUncheckedUpdateWithoutServicioseventosInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type abonoCreateWithoutClienteInput = {
    fecha?: Date | string | null
    cantidad?: number | null
    pagos?: pagosCreateNestedOneWithoutAbonoInput
  }

  export type abonoUncheckedCreateWithoutClienteInput = {
    id?: number
    fecha?: Date | string | null
    cantidad?: number | null
    idpagos?: number | null
  }

  export type abonoCreateOrConnectWithoutClienteInput = {
    where: abonoWhereUniqueInput
    create: XOR<abonoCreateWithoutClienteInput, abonoUncheckedCreateWithoutClienteInput>
  }

  export type abonoCreateManyClienteInputEnvelope = {
    data: Enumerable<abonoCreateManyClienteInput>
    skipDuplicates?: boolean
  }

  export type eventosCreateWithoutClienteInput = {
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    paqueteevento?: paqueteeventoCreateNestedOneWithoutEventosInput
    gastoseventos?: gastoseventosCreateNestedManyWithoutEventosInput
    pagos?: pagosCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosCreateNestedManyWithoutEventosInput
  }

  export type eventosUncheckedCreateWithoutClienteInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idpaquete?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    gastoseventos?: gastoseventosUncheckedCreateNestedManyWithoutEventosInput
    pagos?: pagosUncheckedCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutEventosInput
  }

  export type eventosCreateOrConnectWithoutClienteInput = {
    where: eventosWhereUniqueInput
    create: XOR<eventosCreateWithoutClienteInput, eventosUncheckedCreateWithoutClienteInput>
  }

  export type eventosCreateManyClienteInputEnvelope = {
    data: Enumerable<eventosCreateManyClienteInput>
    skipDuplicates?: boolean
  }

  export type abonoUpsertWithWhereUniqueWithoutClienteInput = {
    where: abonoWhereUniqueInput
    update: XOR<abonoUpdateWithoutClienteInput, abonoUncheckedUpdateWithoutClienteInput>
    create: XOR<abonoCreateWithoutClienteInput, abonoUncheckedCreateWithoutClienteInput>
  }

  export type abonoUpdateWithWhereUniqueWithoutClienteInput = {
    where: abonoWhereUniqueInput
    data: XOR<abonoUpdateWithoutClienteInput, abonoUncheckedUpdateWithoutClienteInput>
  }

  export type abonoUpdateManyWithWhereWithoutClienteInput = {
    where: abonoScalarWhereInput
    data: XOR<abonoUpdateManyMutationInput, abonoUncheckedUpdateManyWithoutAbonoInput>
  }

  export type abonoScalarWhereInput = {
    AND?: Enumerable<abonoScalarWhereInput>
    OR?: Enumerable<abonoScalarWhereInput>
    NOT?: Enumerable<abonoScalarWhereInput>
    id?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    cantidad?: IntNullableFilter | number | null
    idcliente?: IntNullableFilter | number | null
    idpagos?: IntNullableFilter | number | null
  }

  export type eventosUpsertWithWhereUniqueWithoutClienteInput = {
    where: eventosWhereUniqueInput
    update: XOR<eventosUpdateWithoutClienteInput, eventosUncheckedUpdateWithoutClienteInput>
    create: XOR<eventosCreateWithoutClienteInput, eventosUncheckedCreateWithoutClienteInput>
  }

  export type eventosUpdateWithWhereUniqueWithoutClienteInput = {
    where: eventosWhereUniqueInput
    data: XOR<eventosUpdateWithoutClienteInput, eventosUncheckedUpdateWithoutClienteInput>
  }

  export type eventosUpdateManyWithWhereWithoutClienteInput = {
    where: eventosScalarWhereInput
    data: XOR<eventosUpdateManyMutationInput, eventosUncheckedUpdateManyWithoutEventosInput>
  }

  export type eventosScalarWhereInput = {
    AND?: Enumerable<eventosScalarWhereInput>
    OR?: Enumerable<eventosScalarWhereInput>
    NOT?: Enumerable<eventosScalarWhereInput>
    id?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    hora?: DateTimeNullableFilter | Date | string | null
    total?: IntNullableFilter | number | null
    idpaquete?: IntNullableFilter | number | null
    idcliente?: IntNullableFilter | number | null
    celebracion?: StringNullableFilter | string | null
    pagado?: BoolNullableFilter | boolean | null
  }

  export type clienteCreateWithoutEventosInput = {
    nombre?: string | null
    apellido?: string | null
    telefono?: number | null
    direccion?: string | null
    abono?: abonoCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateWithoutEventosInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    telefono?: number | null
    direccion?: string | null
    abono?: abonoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteCreateOrConnectWithoutEventosInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutEventosInput, clienteUncheckedCreateWithoutEventosInput>
  }

  export type paqueteeventoCreateWithoutEventosInput = {
    adultos?: number | null
    ninios?: number | null
    total?: number | null
    paquete?: paqueteCreateNestedOneWithoutPaqueteeventoInput
  }

  export type paqueteeventoUncheckedCreateWithoutEventosInput = {
    id?: number
    adultos?: number | null
    ninios?: number | null
    total?: number | null
    idpaquete?: number | null
  }

  export type paqueteeventoCreateOrConnectWithoutEventosInput = {
    where: paqueteeventoWhereUniqueInput
    create: XOR<paqueteeventoCreateWithoutEventosInput, paqueteeventoUncheckedCreateWithoutEventosInput>
  }

  export type gastoseventosCreateWithoutEventosInput = {
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    mes?: mesCreateNestedOneWithoutGastoseventosInput
  }

  export type gastoseventosUncheckedCreateWithoutEventosInput = {
    id?: number
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    idmes?: number | null
  }

  export type gastoseventosCreateOrConnectWithoutEventosInput = {
    where: gastoseventosWhereUniqueInput
    create: XOR<gastoseventosCreateWithoutEventosInput, gastoseventosUncheckedCreateWithoutEventosInput>
  }

  export type gastoseventosCreateManyEventosInputEnvelope = {
    data: Enumerable<gastoseventosCreateManyEventosInput>
    skipDuplicates?: boolean
  }

  export type pagosCreateWithoutEventosInput = {
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
    abono?: abonoCreateNestedManyWithoutPagosInput
  }

  export type pagosUncheckedCreateWithoutEventosInput = {
    id?: number
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
    abono?: abonoUncheckedCreateNestedManyWithoutPagosInput
  }

  export type pagosCreateOrConnectWithoutEventosInput = {
    where: pagosWhereUniqueInput
    create: XOR<pagosCreateWithoutEventosInput, pagosUncheckedCreateWithoutEventosInput>
  }

  export type pagosCreateManyEventosInputEnvelope = {
    data: Enumerable<pagosCreateManyEventosInput>
    skipDuplicates?: boolean
  }

  export type servicioseventosCreateWithoutEventosInput = {
    precio?: number | null
    empleados?: empleadosCreateNestedOneWithoutServicioseventosInput
    servicios?: serviciosCreateNestedOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedCreateWithoutEventosInput = {
    id?: number
    idservicio?: number | null
    idempleado?: number | null
    precio?: number | null
  }

  export type servicioseventosCreateOrConnectWithoutEventosInput = {
    where: servicioseventosWhereUniqueInput
    create: XOR<servicioseventosCreateWithoutEventosInput, servicioseventosUncheckedCreateWithoutEventosInput>
  }

  export type servicioseventosCreateManyEventosInputEnvelope = {
    data: Enumerable<servicioseventosCreateManyEventosInput>
    skipDuplicates?: boolean
  }

  export type clienteUpsertWithoutEventosInput = {
    update: XOR<clienteUpdateWithoutEventosInput, clienteUncheckedUpdateWithoutEventosInput>
    create: XOR<clienteCreateWithoutEventosInput, clienteUncheckedCreateWithoutEventosInput>
  }

  export type clienteUpdateWithoutEventosInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    abono?: abonoUpdateManyWithoutClienteInput
  }

  export type clienteUncheckedUpdateWithoutEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    abono?: abonoUncheckedUpdateManyWithoutClienteInput
  }

  export type paqueteeventoUpsertWithoutEventosInput = {
    update: XOR<paqueteeventoUpdateWithoutEventosInput, paqueteeventoUncheckedUpdateWithoutEventosInput>
    create: XOR<paqueteeventoCreateWithoutEventosInput, paqueteeventoUncheckedCreateWithoutEventosInput>
  }

  export type paqueteeventoUpdateWithoutEventosInput = {
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    paquete?: paqueteUpdateOneWithoutPaqueteeventoInput
  }

  export type paqueteeventoUncheckedUpdateWithoutEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastoseventosUpsertWithWhereUniqueWithoutEventosInput = {
    where: gastoseventosWhereUniqueInput
    update: XOR<gastoseventosUpdateWithoutEventosInput, gastoseventosUncheckedUpdateWithoutEventosInput>
    create: XOR<gastoseventosCreateWithoutEventosInput, gastoseventosUncheckedCreateWithoutEventosInput>
  }

  export type gastoseventosUpdateWithWhereUniqueWithoutEventosInput = {
    where: gastoseventosWhereUniqueInput
    data: XOR<gastoseventosUpdateWithoutEventosInput, gastoseventosUncheckedUpdateWithoutEventosInput>
  }

  export type gastoseventosUpdateManyWithWhereWithoutEventosInput = {
    where: gastoseventosScalarWhereInput
    data: XOR<gastoseventosUpdateManyMutationInput, gastoseventosUncheckedUpdateManyWithoutGastoseventosInput>
  }

  export type gastoseventosScalarWhereInput = {
    AND?: Enumerable<gastoseventosScalarWhereInput>
    OR?: Enumerable<gastoseventosScalarWhereInput>
    NOT?: Enumerable<gastoseventosScalarWhereInput>
    id?: IntFilter | number
    monto?: IntNullableFilter | number | null
    motivo?: StringNullableFilter | string | null
    descripcion?: StringNullableFilter | string | null
    idmes?: IntNullableFilter | number | null
    idevento?: IntNullableFilter | number | null
  }

  export type pagosUpsertWithWhereUniqueWithoutEventosInput = {
    where: pagosWhereUniqueInput
    update: XOR<pagosUpdateWithoutEventosInput, pagosUncheckedUpdateWithoutEventosInput>
    create: XOR<pagosCreateWithoutEventosInput, pagosUncheckedCreateWithoutEventosInput>
  }

  export type pagosUpdateWithWhereUniqueWithoutEventosInput = {
    where: pagosWhereUniqueInput
    data: XOR<pagosUpdateWithoutEventosInput, pagosUncheckedUpdateWithoutEventosInput>
  }

  export type pagosUpdateManyWithWhereWithoutEventosInput = {
    where: pagosScalarWhereInput
    data: XOR<pagosUpdateManyMutationInput, pagosUncheckedUpdateManyWithoutPagosInput>
  }

  export type pagosScalarWhereInput = {
    AND?: Enumerable<pagosScalarWhereInput>
    OR?: Enumerable<pagosScalarWhereInput>
    NOT?: Enumerable<pagosScalarWhereInput>
    id?: IntFilter | number
    restante?: IntNullableFilter | number | null
    pagado?: IntNullableFilter | number | null
    total?: IntNullableFilter | number | null
    fechalimite?: DateTimeNullableFilter | Date | string | null
    idevento?: IntNullableFilter | number | null
  }

  export type servicioseventosUpsertWithWhereUniqueWithoutEventosInput = {
    where: servicioseventosWhereUniqueInput
    update: XOR<servicioseventosUpdateWithoutEventosInput, servicioseventosUncheckedUpdateWithoutEventosInput>
    create: XOR<servicioseventosCreateWithoutEventosInput, servicioseventosUncheckedCreateWithoutEventosInput>
  }

  export type servicioseventosUpdateWithWhereUniqueWithoutEventosInput = {
    where: servicioseventosWhereUniqueInput
    data: XOR<servicioseventosUpdateWithoutEventosInput, servicioseventosUncheckedUpdateWithoutEventosInput>
  }

  export type servicioseventosUpdateManyWithWhereWithoutEventosInput = {
    where: servicioseventosScalarWhereInput
    data: XOR<servicioseventosUpdateManyMutationInput, servicioseventosUncheckedUpdateManyWithoutServicioseventosInput>
  }

  export type servicioseventosScalarWhereInput = {
    AND?: Enumerable<servicioseventosScalarWhereInput>
    OR?: Enumerable<servicioseventosScalarWhereInput>
    NOT?: Enumerable<servicioseventosScalarWhereInput>
    id?: IntFilter | number
    idevento?: IntNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
    idempleado?: IntNullableFilter | number | null
    precio?: IntNullableFilter | number | null
  }

  export type paqueteeventoCreateWithoutPaqueteInput = {
    adultos?: number | null
    ninios?: number | null
    total?: number | null
    eventos?: eventosCreateNestedManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoUncheckedCreateWithoutPaqueteInput = {
    id?: number
    adultos?: number | null
    ninios?: number | null
    total?: number | null
    eventos?: eventosUncheckedCreateNestedManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoCreateOrConnectWithoutPaqueteInput = {
    where: paqueteeventoWhereUniqueInput
    create: XOR<paqueteeventoCreateWithoutPaqueteInput, paqueteeventoUncheckedCreateWithoutPaqueteInput>
  }

  export type paqueteeventoCreateManyPaqueteInputEnvelope = {
    data: Enumerable<paqueteeventoCreateManyPaqueteInput>
    skipDuplicates?: boolean
  }

  export type paqueteeventoUpsertWithWhereUniqueWithoutPaqueteInput = {
    where: paqueteeventoWhereUniqueInput
    update: XOR<paqueteeventoUpdateWithoutPaqueteInput, paqueteeventoUncheckedUpdateWithoutPaqueteInput>
    create: XOR<paqueteeventoCreateWithoutPaqueteInput, paqueteeventoUncheckedCreateWithoutPaqueteInput>
  }

  export type paqueteeventoUpdateWithWhereUniqueWithoutPaqueteInput = {
    where: paqueteeventoWhereUniqueInput
    data: XOR<paqueteeventoUpdateWithoutPaqueteInput, paqueteeventoUncheckedUpdateWithoutPaqueteInput>
  }

  export type paqueteeventoUpdateManyWithWhereWithoutPaqueteInput = {
    where: paqueteeventoScalarWhereInput
    data: XOR<paqueteeventoUpdateManyMutationInput, paqueteeventoUncheckedUpdateManyWithoutPaqueteeventoInput>
  }

  export type paqueteeventoScalarWhereInput = {
    AND?: Enumerable<paqueteeventoScalarWhereInput>
    OR?: Enumerable<paqueteeventoScalarWhereInput>
    NOT?: Enumerable<paqueteeventoScalarWhereInput>
    id?: IntFilter | number
    adultos?: IntNullableFilter | number | null
    ninios?: IntNullableFilter | number | null
    total?: IntNullableFilter | number | null
    idpaquete?: IntNullableFilter | number | null
  }

  export type paqueteCreateWithoutPaqueteeventoInput = {
    nombre?: string | null
    adultos?: number | null
    ninios?: number | null
    precio?: number | null
    preciounitario?: number | null
  }

  export type paqueteUncheckedCreateWithoutPaqueteeventoInput = {
    id?: number
    nombre?: string | null
    adultos?: number | null
    ninios?: number | null
    precio?: number | null
    preciounitario?: number | null
  }

  export type paqueteCreateOrConnectWithoutPaqueteeventoInput = {
    where: paqueteWhereUniqueInput
    create: XOR<paqueteCreateWithoutPaqueteeventoInput, paqueteUncheckedCreateWithoutPaqueteeventoInput>
  }

  export type eventosCreateWithoutPaqueteeventoInput = {
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    cliente?: clienteCreateNestedOneWithoutEventosInput
    gastoseventos?: gastoseventosCreateNestedManyWithoutEventosInput
    pagos?: pagosCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosCreateNestedManyWithoutEventosInput
  }

  export type eventosUncheckedCreateWithoutPaqueteeventoInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idcliente?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    gastoseventos?: gastoseventosUncheckedCreateNestedManyWithoutEventosInput
    pagos?: pagosUncheckedCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutEventosInput
  }

  export type eventosCreateOrConnectWithoutPaqueteeventoInput = {
    where: eventosWhereUniqueInput
    create: XOR<eventosCreateWithoutPaqueteeventoInput, eventosUncheckedCreateWithoutPaqueteeventoInput>
  }

  export type eventosCreateManyPaqueteeventoInputEnvelope = {
    data: Enumerable<eventosCreateManyPaqueteeventoInput>
    skipDuplicates?: boolean
  }

  export type paqueteUpsertWithoutPaqueteeventoInput = {
    update: XOR<paqueteUpdateWithoutPaqueteeventoInput, paqueteUncheckedUpdateWithoutPaqueteeventoInput>
    create: XOR<paqueteCreateWithoutPaqueteeventoInput, paqueteUncheckedCreateWithoutPaqueteeventoInput>
  }

  export type paqueteUpdateWithoutPaqueteeventoInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    preciounitario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paqueteUncheckedUpdateWithoutPaqueteeventoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    preciounitario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type eventosUpsertWithWhereUniqueWithoutPaqueteeventoInput = {
    where: eventosWhereUniqueInput
    update: XOR<eventosUpdateWithoutPaqueteeventoInput, eventosUncheckedUpdateWithoutPaqueteeventoInput>
    create: XOR<eventosCreateWithoutPaqueteeventoInput, eventosUncheckedCreateWithoutPaqueteeventoInput>
  }

  export type eventosUpdateWithWhereUniqueWithoutPaqueteeventoInput = {
    where: eventosWhereUniqueInput
    data: XOR<eventosUpdateWithoutPaqueteeventoInput, eventosUncheckedUpdateWithoutPaqueteeventoInput>
  }

  export type eventosUpdateManyWithWhereWithoutPaqueteeventoInput = {
    where: eventosScalarWhereInput
    data: XOR<eventosUpdateManyMutationInput, eventosUncheckedUpdateManyWithoutEventosInput>
  }

  export type clienteCreateWithoutAbonoInput = {
    nombre?: string | null
    apellido?: string | null
    telefono?: number | null
    direccion?: string | null
    eventos?: eventosCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateWithoutAbonoInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    telefono?: number | null
    direccion?: string | null
    eventos?: eventosUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteCreateOrConnectWithoutAbonoInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutAbonoInput, clienteUncheckedCreateWithoutAbonoInput>
  }

  export type pagosCreateWithoutAbonoInput = {
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
    eventos?: eventosCreateNestedOneWithoutPagosInput
  }

  export type pagosUncheckedCreateWithoutAbonoInput = {
    id?: number
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
    idevento?: number | null
  }

  export type pagosCreateOrConnectWithoutAbonoInput = {
    where: pagosWhereUniqueInput
    create: XOR<pagosCreateWithoutAbonoInput, pagosUncheckedCreateWithoutAbonoInput>
  }

  export type clienteUpsertWithoutAbonoInput = {
    update: XOR<clienteUpdateWithoutAbonoInput, clienteUncheckedUpdateWithoutAbonoInput>
    create: XOR<clienteCreateWithoutAbonoInput, clienteUncheckedCreateWithoutAbonoInput>
  }

  export type clienteUpdateWithoutAbonoInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: eventosUpdateManyWithoutClienteInput
  }

  export type clienteUncheckedUpdateWithoutAbonoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: eventosUncheckedUpdateManyWithoutClienteInput
  }

  export type pagosUpsertWithoutAbonoInput = {
    update: XOR<pagosUpdateWithoutAbonoInput, pagosUncheckedUpdateWithoutAbonoInput>
    create: XOR<pagosCreateWithoutAbonoInput, pagosUncheckedCreateWithoutAbonoInput>
  }

  export type pagosUpdateWithoutAbonoInput = {
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventos?: eventosUpdateOneWithoutPagosInput
  }

  export type pagosUncheckedUpdateWithoutAbonoInput = {
    id?: IntFieldUpdateOperationsInput | number
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolCreateWithoutEmpleadosInput = {
    rol?: string | null
  }

  export type rolUncheckedCreateWithoutEmpleadosInput = {
    id?: number
    rol?: string | null
  }

  export type rolCreateOrConnectWithoutEmpleadosInput = {
    where: rolWhereUniqueInput
    create: XOR<rolCreateWithoutEmpleadosInput, rolUncheckedCreateWithoutEmpleadosInput>
  }

  export type servicioseventosCreateWithoutEmpleadosInput = {
    precio?: number | null
    eventos?: eventosCreateNestedOneWithoutServicioseventosInput
    servicios?: serviciosCreateNestedOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedCreateWithoutEmpleadosInput = {
    id?: number
    idevento?: number | null
    idservicio?: number | null
    precio?: number | null
  }

  export type servicioseventosCreateOrConnectWithoutEmpleadosInput = {
    where: servicioseventosWhereUniqueInput
    create: XOR<servicioseventosCreateWithoutEmpleadosInput, servicioseventosUncheckedCreateWithoutEmpleadosInput>
  }

  export type servicioseventosCreateManyEmpleadosInputEnvelope = {
    data: Enumerable<servicioseventosCreateManyEmpleadosInput>
    skipDuplicates?: boolean
  }

  export type rolUpsertWithoutEmpleadosInput = {
    update: XOR<rolUpdateWithoutEmpleadosInput, rolUncheckedUpdateWithoutEmpleadosInput>
    create: XOR<rolCreateWithoutEmpleadosInput, rolUncheckedCreateWithoutEmpleadosInput>
  }

  export type rolUpdateWithoutEmpleadosInput = {
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolUncheckedUpdateWithoutEmpleadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicioseventosUpsertWithWhereUniqueWithoutEmpleadosInput = {
    where: servicioseventosWhereUniqueInput
    update: XOR<servicioseventosUpdateWithoutEmpleadosInput, servicioseventosUncheckedUpdateWithoutEmpleadosInput>
    create: XOR<servicioseventosCreateWithoutEmpleadosInput, servicioseventosUncheckedCreateWithoutEmpleadosInput>
  }

  export type servicioseventosUpdateWithWhereUniqueWithoutEmpleadosInput = {
    where: servicioseventosWhereUniqueInput
    data: XOR<servicioseventosUpdateWithoutEmpleadosInput, servicioseventosUncheckedUpdateWithoutEmpleadosInput>
  }

  export type servicioseventosUpdateManyWithWhereWithoutEmpleadosInput = {
    where: servicioseventosScalarWhereInput
    data: XOR<servicioseventosUpdateManyMutationInput, servicioseventosUncheckedUpdateManyWithoutServicioseventosInput>
  }

  export type eventosCreateWithoutGastoseventosInput = {
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    cliente?: clienteCreateNestedOneWithoutEventosInput
    paqueteevento?: paqueteeventoCreateNestedOneWithoutEventosInput
    pagos?: pagosCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosCreateNestedManyWithoutEventosInput
  }

  export type eventosUncheckedCreateWithoutGastoseventosInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idpaquete?: number | null
    idcliente?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    pagos?: pagosUncheckedCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutEventosInput
  }

  export type eventosCreateOrConnectWithoutGastoseventosInput = {
    where: eventosWhereUniqueInput
    create: XOR<eventosCreateWithoutGastoseventosInput, eventosUncheckedCreateWithoutGastoseventosInput>
  }

  export type mesCreateWithoutGastoseventosInput = {
    mes?: Date | string | null
    gastos?: number | null
    ganancias?: number | null
  }

  export type mesUncheckedCreateWithoutGastoseventosInput = {
    id?: number
    mes?: Date | string | null
    gastos?: number | null
    ganancias?: number | null
  }

  export type mesCreateOrConnectWithoutGastoseventosInput = {
    where: mesWhereUniqueInput
    create: XOR<mesCreateWithoutGastoseventosInput, mesUncheckedCreateWithoutGastoseventosInput>
  }

  export type eventosUpsertWithoutGastoseventosInput = {
    update: XOR<eventosUpdateWithoutGastoseventosInput, eventosUncheckedUpdateWithoutGastoseventosInput>
    create: XOR<eventosCreateWithoutGastoseventosInput, eventosUncheckedCreateWithoutGastoseventosInput>
  }

  export type eventosUpdateWithoutGastoseventosInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cliente?: clienteUpdateOneWithoutEventosInput
    paqueteevento?: paqueteeventoUpdateOneWithoutEventosInput
    pagos?: pagosUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUpdateManyWithoutEventosInput
  }

  export type eventosUncheckedUpdateWithoutGastoseventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pagos?: pagosUncheckedUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutEventosInput
  }

  export type mesUpsertWithoutGastoseventosInput = {
    update: XOR<mesUpdateWithoutGastoseventosInput, mesUncheckedUpdateWithoutGastoseventosInput>
    create: XOR<mesCreateWithoutGastoseventosInput, mesUncheckedCreateWithoutGastoseventosInput>
  }

  export type mesUpdateWithoutGastoseventosInput = {
    mes?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableIntFieldUpdateOperationsInput | number | null
    ganancias?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mesUncheckedUpdateWithoutGastoseventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    mes?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableIntFieldUpdateOperationsInput | number | null
    ganancias?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastoseventosCreateWithoutMesInput = {
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    eventos?: eventosCreateNestedOneWithoutGastoseventosInput
  }

  export type gastoseventosUncheckedCreateWithoutMesInput = {
    id?: number
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    idevento?: number | null
  }

  export type gastoseventosCreateOrConnectWithoutMesInput = {
    where: gastoseventosWhereUniqueInput
    create: XOR<gastoseventosCreateWithoutMesInput, gastoseventosUncheckedCreateWithoutMesInput>
  }

  export type gastoseventosCreateManyMesInputEnvelope = {
    data: Enumerable<gastoseventosCreateManyMesInput>
    skipDuplicates?: boolean
  }

  export type gastoseventosUpsertWithWhereUniqueWithoutMesInput = {
    where: gastoseventosWhereUniqueInput
    update: XOR<gastoseventosUpdateWithoutMesInput, gastoseventosUncheckedUpdateWithoutMesInput>
    create: XOR<gastoseventosCreateWithoutMesInput, gastoseventosUncheckedCreateWithoutMesInput>
  }

  export type gastoseventosUpdateWithWhereUniqueWithoutMesInput = {
    where: gastoseventosWhereUniqueInput
    data: XOR<gastoseventosUpdateWithoutMesInput, gastoseventosUncheckedUpdateWithoutMesInput>
  }

  export type gastoseventosUpdateManyWithWhereWithoutMesInput = {
    where: gastoseventosScalarWhereInput
    data: XOR<gastoseventosUpdateManyMutationInput, gastoseventosUncheckedUpdateManyWithoutGastoseventosInput>
  }

  export type eventosCreateWithoutPagosInput = {
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    cliente?: clienteCreateNestedOneWithoutEventosInput
    paqueteevento?: paqueteeventoCreateNestedOneWithoutEventosInput
    gastoseventos?: gastoseventosCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosCreateNestedManyWithoutEventosInput
  }

  export type eventosUncheckedCreateWithoutPagosInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idpaquete?: number | null
    idcliente?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    gastoseventos?: gastoseventosUncheckedCreateNestedManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutEventosInput
  }

  export type eventosCreateOrConnectWithoutPagosInput = {
    where: eventosWhereUniqueInput
    create: XOR<eventosCreateWithoutPagosInput, eventosUncheckedCreateWithoutPagosInput>
  }

  export type abonoCreateWithoutPagosInput = {
    fecha?: Date | string | null
    cantidad?: number | null
    cliente?: clienteCreateNestedOneWithoutAbonoInput
  }

  export type abonoUncheckedCreateWithoutPagosInput = {
    id?: number
    fecha?: Date | string | null
    cantidad?: number | null
    idcliente?: number | null
  }

  export type abonoCreateOrConnectWithoutPagosInput = {
    where: abonoWhereUniqueInput
    create: XOR<abonoCreateWithoutPagosInput, abonoUncheckedCreateWithoutPagosInput>
  }

  export type abonoCreateManyPagosInputEnvelope = {
    data: Enumerable<abonoCreateManyPagosInput>
    skipDuplicates?: boolean
  }

  export type eventosUpsertWithoutPagosInput = {
    update: XOR<eventosUpdateWithoutPagosInput, eventosUncheckedUpdateWithoutPagosInput>
    create: XOR<eventosCreateWithoutPagosInput, eventosUncheckedCreateWithoutPagosInput>
  }

  export type eventosUpdateWithoutPagosInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cliente?: clienteUpdateOneWithoutEventosInput
    paqueteevento?: paqueteeventoUpdateOneWithoutEventosInput
    gastoseventos?: gastoseventosUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUpdateManyWithoutEventosInput
  }

  export type eventosUncheckedUpdateWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gastoseventos?: gastoseventosUncheckedUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutEventosInput
  }

  export type abonoUpsertWithWhereUniqueWithoutPagosInput = {
    where: abonoWhereUniqueInput
    update: XOR<abonoUpdateWithoutPagosInput, abonoUncheckedUpdateWithoutPagosInput>
    create: XOR<abonoCreateWithoutPagosInput, abonoUncheckedCreateWithoutPagosInput>
  }

  export type abonoUpdateWithWhereUniqueWithoutPagosInput = {
    where: abonoWhereUniqueInput
    data: XOR<abonoUpdateWithoutPagosInput, abonoUncheckedUpdateWithoutPagosInput>
  }

  export type abonoUpdateManyWithWhereWithoutPagosInput = {
    where: abonoScalarWhereInput
    data: XOR<abonoUpdateManyMutationInput, abonoUncheckedUpdateManyWithoutAbonoInput>
  }

  export type empleadosCreateWithoutRolInput = {
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
    servicioseventos?: servicioseventosCreateNestedManyWithoutEmpleadosInput
  }

  export type empleadosUncheckedCreateWithoutRolInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
    servicioseventos?: servicioseventosUncheckedCreateNestedManyWithoutEmpleadosInput
  }

  export type empleadosCreateOrConnectWithoutRolInput = {
    where: empleadosWhereUniqueInput
    create: XOR<empleadosCreateWithoutRolInput, empleadosUncheckedCreateWithoutRolInput>
  }

  export type empleadosCreateManyRolInputEnvelope = {
    data: Enumerable<empleadosCreateManyRolInput>
    skipDuplicates?: boolean
  }

  export type empleadosUpsertWithWhereUniqueWithoutRolInput = {
    where: empleadosWhereUniqueInput
    update: XOR<empleadosUpdateWithoutRolInput, empleadosUncheckedUpdateWithoutRolInput>
    create: XOR<empleadosCreateWithoutRolInput, empleadosUncheckedCreateWithoutRolInput>
  }

  export type empleadosUpdateWithWhereUniqueWithoutRolInput = {
    where: empleadosWhereUniqueInput
    data: XOR<empleadosUpdateWithoutRolInput, empleadosUncheckedUpdateWithoutRolInput>
  }

  export type empleadosUpdateManyWithWhereWithoutRolInput = {
    where: empleadosScalarWhereInput
    data: XOR<empleadosUpdateManyMutationInput, empleadosUncheckedUpdateManyWithoutEmpleadosInput>
  }

  export type empleadosScalarWhereInput = {
    AND?: Enumerable<empleadosScalarWhereInput>
    OR?: Enumerable<empleadosScalarWhereInput>
    NOT?: Enumerable<empleadosScalarWhereInput>
    id?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    direccion?: StringNullableFilter | string | null
    telefono?: IntNullableFilter | number | null
    descripcion?: StringNullableFilter | string | null
    idrol?: IntNullableFilter | number | null
  }

  export type servicioseventosCreateWithoutServiciosInput = {
    precio?: number | null
    empleados?: empleadosCreateNestedOneWithoutServicioseventosInput
    eventos?: eventosCreateNestedOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedCreateWithoutServiciosInput = {
    id?: number
    idevento?: number | null
    idempleado?: number | null
    precio?: number | null
  }

  export type servicioseventosCreateOrConnectWithoutServiciosInput = {
    where: servicioseventosWhereUniqueInput
    create: XOR<servicioseventosCreateWithoutServiciosInput, servicioseventosUncheckedCreateWithoutServiciosInput>
  }

  export type servicioseventosCreateManyServiciosInputEnvelope = {
    data: Enumerable<servicioseventosCreateManyServiciosInput>
    skipDuplicates?: boolean
  }

  export type servicioseventosUpsertWithWhereUniqueWithoutServiciosInput = {
    where: servicioseventosWhereUniqueInput
    update: XOR<servicioseventosUpdateWithoutServiciosInput, servicioseventosUncheckedUpdateWithoutServiciosInput>
    create: XOR<servicioseventosCreateWithoutServiciosInput, servicioseventosUncheckedCreateWithoutServiciosInput>
  }

  export type servicioseventosUpdateWithWhereUniqueWithoutServiciosInput = {
    where: servicioseventosWhereUniqueInput
    data: XOR<servicioseventosUpdateWithoutServiciosInput, servicioseventosUncheckedUpdateWithoutServiciosInput>
  }

  export type servicioseventosUpdateManyWithWhereWithoutServiciosInput = {
    where: servicioseventosScalarWhereInput
    data: XOR<servicioseventosUpdateManyMutationInput, servicioseventosUncheckedUpdateManyWithoutServicioseventosInput>
  }

  export type empleadosCreateWithoutServicioseventosInput = {
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
    rol?: rolCreateNestedOneWithoutEmpleadosInput
  }

  export type empleadosUncheckedCreateWithoutServicioseventosInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
    idrol?: number | null
  }

  export type empleadosCreateOrConnectWithoutServicioseventosInput = {
    where: empleadosWhereUniqueInput
    create: XOR<empleadosCreateWithoutServicioseventosInput, empleadosUncheckedCreateWithoutServicioseventosInput>
  }

  export type eventosCreateWithoutServicioseventosInput = {
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    cliente?: clienteCreateNestedOneWithoutEventosInput
    paqueteevento?: paqueteeventoCreateNestedOneWithoutEventosInput
    gastoseventos?: gastoseventosCreateNestedManyWithoutEventosInput
    pagos?: pagosCreateNestedManyWithoutEventosInput
  }

  export type eventosUncheckedCreateWithoutServicioseventosInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idpaquete?: number | null
    idcliente?: number | null
    celebracion?: string | null
    pagado?: boolean | null
    gastoseventos?: gastoseventosUncheckedCreateNestedManyWithoutEventosInput
    pagos?: pagosUncheckedCreateNestedManyWithoutEventosInput
  }

  export type eventosCreateOrConnectWithoutServicioseventosInput = {
    where: eventosWhereUniqueInput
    create: XOR<eventosCreateWithoutServicioseventosInput, eventosUncheckedCreateWithoutServicioseventosInput>
  }

  export type serviciosCreateWithoutServicioseventosInput = {
    nombre?: string | null
    precio?: number | null
    descripcion?: string | null
  }

  export type serviciosUncheckedCreateWithoutServicioseventosInput = {
    id?: number
    nombre?: string | null
    precio?: number | null
    descripcion?: string | null
  }

  export type serviciosCreateOrConnectWithoutServicioseventosInput = {
    where: serviciosWhereUniqueInput
    create: XOR<serviciosCreateWithoutServicioseventosInput, serviciosUncheckedCreateWithoutServicioseventosInput>
  }

  export type empleadosUpsertWithoutServicioseventosInput = {
    update: XOR<empleadosUpdateWithoutServicioseventosInput, empleadosUncheckedUpdateWithoutServicioseventosInput>
    create: XOR<empleadosCreateWithoutServicioseventosInput, empleadosUncheckedCreateWithoutServicioseventosInput>
  }

  export type empleadosUpdateWithoutServicioseventosInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    rol?: rolUpdateOneWithoutEmpleadosInput
  }

  export type empleadosUncheckedUpdateWithoutServicioseventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idrol?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type eventosUpsertWithoutServicioseventosInput = {
    update: XOR<eventosUpdateWithoutServicioseventosInput, eventosUncheckedUpdateWithoutServicioseventosInput>
    create: XOR<eventosCreateWithoutServicioseventosInput, eventosUncheckedCreateWithoutServicioseventosInput>
  }

  export type eventosUpdateWithoutServicioseventosInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cliente?: clienteUpdateOneWithoutEventosInput
    paqueteevento?: paqueteeventoUpdateOneWithoutEventosInput
    gastoseventos?: gastoseventosUpdateManyWithoutEventosInput
    pagos?: pagosUpdateManyWithoutEventosInput
  }

  export type eventosUncheckedUpdateWithoutServicioseventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gastoseventos?: gastoseventosUncheckedUpdateManyWithoutEventosInput
    pagos?: pagosUncheckedUpdateManyWithoutEventosInput
  }

  export type serviciosUpsertWithoutServicioseventosInput = {
    update: XOR<serviciosUpdateWithoutServicioseventosInput, serviciosUncheckedUpdateWithoutServicioseventosInput>
    create: XOR<serviciosCreateWithoutServicioseventosInput, serviciosUncheckedCreateWithoutServicioseventosInput>
  }

  export type serviciosUpdateWithoutServicioseventosInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateWithoutServicioseventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type abonoCreateManyClienteInput = {
    id?: number
    fecha?: Date | string | null
    cantidad?: number | null
    idpagos?: number | null
  }

  export type eventosCreateManyClienteInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idpaquete?: number | null
    celebracion?: string | null
    pagado?: boolean | null
  }

  export type abonoUpdateWithoutClienteInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    pagos?: pagosUpdateOneWithoutAbonoInput
  }

  export type abonoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    idpagos?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type abonoUncheckedUpdateManyWithoutAbonoInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    idpagos?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type eventosUpdateWithoutClienteInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paqueteevento?: paqueteeventoUpdateOneWithoutEventosInput
    gastoseventos?: gastoseventosUpdateManyWithoutEventosInput
    pagos?: pagosUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUpdateManyWithoutEventosInput
  }

  export type eventosUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gastoseventos?: gastoseventosUncheckedUpdateManyWithoutEventosInput
    pagos?: pagosUncheckedUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutEventosInput
  }

  export type eventosUncheckedUpdateManyWithoutEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idpaquete?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type gastoseventosCreateManyEventosInput = {
    id?: number
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    idmes?: number | null
  }

  export type pagosCreateManyEventosInput = {
    id?: number
    restante?: number | null
    pagado?: number | null
    total?: number | null
    fechalimite?: Date | string | null
  }

  export type servicioseventosCreateManyEventosInput = {
    id?: number
    idservicio?: number | null
    idempleado?: number | null
    precio?: number | null
  }

  export type gastoseventosUpdateWithoutEventosInput = {
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: mesUpdateOneWithoutGastoseventosInput
  }

  export type gastoseventosUncheckedUpdateWithoutEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastoseventosUncheckedUpdateManyWithoutGastoseventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idmes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pagosUpdateWithoutEventosInput = {
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abono?: abonoUpdateManyWithoutPagosInput
  }

  export type pagosUncheckedUpdateWithoutEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abono?: abonoUncheckedUpdateManyWithoutPagosInput
  }

  export type pagosUncheckedUpdateManyWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    restante?: NullableIntFieldUpdateOperationsInput | number | null
    pagado?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    fechalimite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type servicioseventosUpdateWithoutEventosInput = {
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    empleados?: empleadosUpdateOneWithoutServicioseventosInput
    servicios?: serviciosUpdateOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedUpdateWithoutEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    idempleado?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicioseventosUncheckedUpdateManyWithoutServicioseventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    idempleado?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type paqueteeventoCreateManyPaqueteInput = {
    id?: number
    adultos?: number | null
    ninios?: number | null
    total?: number | null
  }

  export type paqueteeventoUpdateWithoutPaqueteInput = {
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    eventos?: eventosUpdateManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoUncheckedUpdateWithoutPaqueteInput = {
    id?: IntFieldUpdateOperationsInput | number
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    eventos?: eventosUncheckedUpdateManyWithoutPaqueteeventoInput
  }

  export type paqueteeventoUncheckedUpdateManyWithoutPaqueteeventoInput = {
    id?: IntFieldUpdateOperationsInput | number
    adultos?: NullableIntFieldUpdateOperationsInput | number | null
    ninios?: NullableIntFieldUpdateOperationsInput | number | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type eventosCreateManyPaqueteeventoInput = {
    id?: number
    fecha?: Date | string | null
    hora?: Date | string | null
    total?: number | null
    idcliente?: number | null
    celebracion?: string | null
    pagado?: boolean | null
  }

  export type eventosUpdateWithoutPaqueteeventoInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cliente?: clienteUpdateOneWithoutEventosInput
    gastoseventos?: gastoseventosUpdateManyWithoutEventosInput
    pagos?: pagosUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUpdateManyWithoutEventosInput
  }

  export type eventosUncheckedUpdateWithoutPaqueteeventoInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    celebracion?: NullableStringFieldUpdateOperationsInput | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gastoseventos?: gastoseventosUncheckedUpdateManyWithoutEventosInput
    pagos?: pagosUncheckedUpdateManyWithoutEventosInput
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutEventosInput
  }

  export type servicioseventosCreateManyEmpleadosInput = {
    id?: number
    idevento?: number | null
    idservicio?: number | null
    precio?: number | null
  }

  export type servicioseventosUpdateWithoutEmpleadosInput = {
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    eventos?: eventosUpdateOneWithoutServicioseventosInput
    servicios?: serviciosUpdateOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedUpdateWithoutEmpleadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastoseventosCreateManyMesInput = {
    id?: number
    monto?: number | null
    motivo?: string | null
    descripcion?: string | null
    idevento?: number | null
  }

  export type gastoseventosUpdateWithoutMesInput = {
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    eventos?: eventosUpdateOneWithoutGastoseventosInput
  }

  export type gastoseventosUncheckedUpdateWithoutMesInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type abonoCreateManyPagosInput = {
    id?: number
    fecha?: Date | string | null
    cantidad?: number | null
    idcliente?: number | null
  }

  export type abonoUpdateWithoutPagosInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    cliente?: clienteUpdateOneWithoutAbonoInput
  }

  export type abonoUncheckedUpdateWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empleadosCreateManyRolInput = {
    id?: number
    nombre?: string | null
    apellido?: string | null
    direccion?: string | null
    telefono?: number | null
    descripcion?: string | null
  }

  export type empleadosUpdateWithoutRolInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    servicioseventos?: servicioseventosUpdateManyWithoutEmpleadosInput
  }

  export type empleadosUncheckedUpdateWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    servicioseventos?: servicioseventosUncheckedUpdateManyWithoutEmpleadosInput
  }

  export type empleadosUncheckedUpdateManyWithoutEmpleadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicioseventosCreateManyServiciosInput = {
    id?: number
    idevento?: number | null
    idempleado?: number | null
    precio?: number | null
  }

  export type servicioseventosUpdateWithoutServiciosInput = {
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    empleados?: empleadosUpdateOneWithoutServicioseventosInput
    eventos?: eventosUpdateOneWithoutServicioseventosInput
  }

  export type servicioseventosUncheckedUpdateWithoutServiciosInput = {
    id?: IntFieldUpdateOperationsInput | number
    idevento?: NullableIntFieldUpdateOperationsInput | number | null
    idempleado?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}